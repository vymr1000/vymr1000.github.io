---
layout: post
category: 2021
---

<br/>

> [트랜잭션에 대해](#트랜잭션에-대해)     
> [ACID중 Consistency(일관성)에 대해](#acid중-consistency일관성에-대해)           
> [트랜잭션 격리수준에 대해](#트랜잭션-격리수준에-대해)


## 트랜잭션에 대해

---
{: data-content="핵심"}

트랜잭션은 **데이터베이스의 상태**를 변환시키는 하나 이상의 연산들의 집합으로, 이들 연산들은 한꺼번에 수행되거나 전혀 수행되지 않아야 함을 보장하는 기능입니다. 이는 데이터베이스의 일관성을 보장하는 중요한 메커니즘입니다. 트랜잭션의 주요 특성은 **ACID(Atomicity, Consistency, Isolation, Durability)로 요약**됩니다.

---
{: data-content="자세한 설명"}

Atomicity(원자성): 트랜잭션 내의 모든 연산은 한꺼번에 수행되거나 아예 수행되지 않아야 합니다. 즉, 트랜잭션의 연산은 부분적으로 실행되지 않음을 보장합니다.

Consistency(일관성): 일관성은 트랜잭션 실행 전과 후의 데이터 상태가 일관되게 유지된다는 것을 보장합니다. 즉, 트랜잭션이 일어난 이후의 데이터베이스는 **데이터베이스의 제약이나 규칙을 만족**해야 한다는 뜻입니다.

Isolation(독립성): 동시에 수행되는 여러 트랜잭션들이 서로에게 영향을 주지 않음을 보장합니다. 각 트랜잭션은 독립적인 수행을 완료하고, 다른 트랜잭션의 중간 결과를 볼 수 없습니다.

Durability(영속성): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 합니다. 시스템 장애가 발생해도 이는 보장되어야 합니다.

이렇게 트랜잭션이 ACID 속성을 통해 데이터의 일관성을 보장하며, 이는 데이터베이스 시스템에서 매우 중요한 역할을 합니다.


## ACID중 Consistency(일관성)에 대해

---
{: data-content="핵심"}

일관성이란 트랜잭션이 데이터 무결성에 대한 제약 조건을 만족되어야 함을 의미합니다. 즉, 데이터는 모순이 없어야 합니다. 트랜잭션이 제약 조건을 위반하는 경우 일관성을 통해 트랜잭션이 실행되지 않고 이전의 상태로 롤백됩니다.

---
{: data-content="자세한 설명"}
일관성에 대해 더 자세히 이해하기 위해 예를 들어보겠습니다. 데이터베이스에 "모든 사용자는 이메일 주소를 가져야 한다"는 무결성 제약 조건이 있다고 가정해봅시다. 새 사용자를 생성하는 트랜잭션은 이메일 주소를 제공하지 않으면 실패해야 합니다. 트랜잭션이 성공적으로 완료된 후에는 모든 사용자가 여전히 이메일 주소를 가지고 있어야 하므로 데이터베이스는 일관된 상태를 유지합니다. 이와 같이 일관성은 데이터베이스의 무결성 제약 조건을 유지하면서 트랜잭션의 실행을 보장하는 속성입니다.


## 트랜잭션 격리수준에 대해

---
{: data-content="핵심"}

트랜잭션 격리 수준(Transaction Isolation Level)이란, 동시에 여러 트랜잭션이 처리될 때, 트랜잭션들이 서로에게 미치는 영향을 어느 정도 허용할지를 결정하는 것입니다. SQL 표준에서는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4가지 수준을 정의하고 있습니다.

---
{: data-content="자세한 설명"}

각 격리 수준은 다음과 같은 성질을 가집니다:

READ UNCOMMITTED (읽기 미완료): 가장 낮은 격리 수준으로, 한 트랜잭션에서 처리 중인 변경 내용이 Commit 여부와 상관없이 다른 트랜잭션에서 보일 수 있습니다. 이로 인해 Dirty Read, Non-Repeatable Read, Phantom Read와 같은 문제가 발생할 수 있습니다.

READ COMMITTED (읽기 완료): Commit된 데이터만 읽을 수 있으므로 Dirty Read는 방지하지만, 트랜잭션 도중 다른 트랜잭션에서 변경한 데이터를 볼 수 있으므로 Non-Repeatable Read와 Phantom Read는 여전히 발생할 수 있습니다.

REPEATABLE READ (반복 가능한 읽기): 한 트랜잭션 내에서 동일한 결과를 보장하므로 Non-Repeatable Read는 방지하지만, 새로운 데이터가 추가된 경우에 대해선 이를 보장하지 못해 Phantom Read가 발생할 수 있습니다.

SERIALIZABLE (직렬화 가능): 가장 높은 격리 수준으로, 여러 트랜잭션이 동일한 레코드에 접근할 수 없습니다. 트랜잭션이 순차적으로 실행되도록 하여 모든 데이터 부정합 문제를 방지합니다. 즉, 순수한 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락, Shared Lock)으로 건다. 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없습니다. 하지만 이는 동시 처리 성능에 부정적인 영향을 미칠 수 있습니다. 

이러한 격리 수준에 따른 문제를 해결하기 위해선 일반적으로 Locking, MVCC(Multi Version Concurrency Control) 등의 기법이 사용되며, DBMS마다 이를 다루는 방식에 차이가 있습니다. 따라서 개발자는 어플리케이션의 특성과 DBMS의 동작 방식을 고려하여 적절한 트랜잭션 격리 수준을 설정해야 합니다.