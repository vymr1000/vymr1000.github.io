---
layout: post
category: 2023
---

<br/>

> Spring 및 SpringBoot의 구조, 동작과정 및 기본 원리에 대한 개념 정리

<br/>

## Spring의 동작과정에 대해

---
{: data-content="핵심"}

Spring 애플리케이션이 시작하는 단계는 크게 설정 파일 로드, IoC 컨테이너 초기화 및 Bean 생성, 등록으로 나눌 수 있습니다. 이 과정은 Spring 프레임워크가 개발자 대신 객체의 생명 주기와 의존성을 관리하는 Inversion of Control(IoC) 원칙을 구현하는 것입니다.

---
{: data-content="자세한 설명"}

Spring Framework의 실행 단계는 다음과 같습니다:

1. 설정 파일 로드: 애플리케이션이 시작하면 먼저 Spring IoC 컨테이너는 설정 파일을 로드합니다. 이 설정 파일은 XML이거나 Java Config 등 다양한 형식이 될 수 있습니다. 설정 파일은 애플리케이션의 구성 요소인 Bean들과 이들의 의존성을 정의합니다.

2. IoC 컨테이너 초기화 및 Bean 생성: 설정 파일이 로드되면 IoC 컨테이너는 Bean 정의를 읽어들여 필요한 객체를 생성합니다. 이때 생성된 객체는 해당 Bean 정의에 따른 속성값과 의존성을 가지게 됩니다. 의존성은 다른 Bean들로부터 주입(Dependency Injection)받습니다.

3. Bean 등록 및 사용 준비: IoC 컨테이너는 생성된 Bean을 내부의 Bean 팩토리나 Bean 컨텍스트 등에 등록합니다. 이렇게 등록된 Bean은 애플리케이션의 다른 부분에서 필요할 때 IoC 컨테이너로부터 요청받아 사용될 수 있습니다.

이 과정들이 완료되면, Spring 애플리케이션이 정상적으로 작동할 수 있는 상태가 됩니다. 이는 Spring의 핵심 원칙인 IoC를 실현하는 과정으로, 개발자는 복잡한 객체 생성과 관리, 의존성 주입 과정을 Spring 프레임워크에 맡김으로써 비즈니스 로직에 집중할 수 있게 됩니다.

## SpringBoot의 동작과정에 대해

---
{: data-content="핵심"}

SpringBoot 애플리케이션과 Spring 애플리케이션의 시작 단계는 기본적으로 동일하나, SpringBoot는 추가적인 자동 구성(자동 설정), 내장 서버 등의 기능을 제공하여 초기 구성을 보다 간편하게 합니다.

---
{: data-content="자세한 설명"}

SpringBoot의 실행 단계는 다음과 같습니다:

1. 설정 파일 로드: 둘 다 설정 파일을 로드하는 것은 같으나, SpringBoot는 Spring의 복잡한 XML 설정을 대체하는 자바 기반의 구성을 선호하며, 'starters' 라는 의존성 집합을 이용하여 추가적인 설정 없이 필요한 라이브러리들을 쉽게 포함시킬 수 있습니다.

2. IoC 컨테이너 초기화 및 Bean 생성: SpringBoot 애플리케이션은 Spring 애플리케이션과 같이 IoC 컨테이너를 초기화하고, Bean을 생성합니다. 하지만 SpringBoot는 추가적으로 '자동 구성' 기능을 제공합니다. 이 기능을 통해 SpringBoot는 클래스 경로 설정, 다른 Bean들, 다양한 프로퍼티 설정 등을 기반으로 자동으로 Bean을 구성하고 생성할 수 있습니다.

3. 내장 서버: Spring 애플리케이션은 외부 서버에 배포되어 실행되는 반면, SpringBoot는 톰캣 같은 내장 서버를 제공하여 별도의 서버 없이도 독립적으로 실행될 수 있습니다. 이를 통해 개발 및 테스트 과정을 간소화하고 빠르게 애플리케이션을 실행시킬 수 있습니다.

따라서, SpringBoot는 Spring 프레임워크의 기본 원칙을 그대로 유지하면서, 개발 및 배포 과정을 간편하게 해주는 여러 추가 기능을 제공합니다. 이로 인해 개발자는 복잡한 설정 과정을 크게 단순화하고, 비즈니스 로직에 더욱 집중할 수 있게 되었습니다.


## Spring과 SpringBoot의 차이에 대해

---
{: data-content="핵심"}

Spring과 Spring Boot의 기본적인 차이는 설정과 간소화입니다. Spring Boot는 Spring 기반 애플리케이션을 빠르고 쉽게 구축할 수 있는 미리 설정된 기본 설정을 제공합니다.

---
{: data-content="자세한 설명"}
Spring Framework는 대규모 Java 애플리케이션을 개발하는 데 널리 사용되는 오픈 소스 프레임워크입니다. 이는 IoC(Inversion of Control)와 DI(Dependency Injection)와 같은 강력한 기능을 제공하며, 데이터 액세스, 트랜잭션 관리, MVC 웹 애플리케이션 개발, 쉽게 사용 가능한 보안 구성 등과 같은 다양한 모듈을 제공합니다.

그러나 Spring Framework를 사용하여 애플리케이션을 설정하고 부트스트랩하는 과정은 복잡할 수 있습니다. 다양한 모듈을 수동으로 설정하고, 데이터 소스, 뷰 리졸버, 메시지 소스 등을 구성하고 관리해야 합니다.

이러한 복잡성을 해결하기 위해 Spring Boot가 만들어졌습니다. Spring Boot는 단독 실행 가능한 애플리케이션을 생성하는 방법, 즉 'spring을 위한 spring'을 제공하며, 개발자가 애플리케이션을 빠르게 시작하고 실행할 수 있도록 지원합니다. Spring Boot는 'opinionated defaults'를 제공하여 개발자가 설정을 최소화하고 빠르게 개발에 집중할 수 있도록 합니다.

Spring Boot는 또한 기본값이 설정된 내장된 서버(예: Tomcat, Jetty)를 제공하여 개발자가 쉽게 웹 애플리케이션을 빌드하고 배포할 수 있게 합니다. 이로 인해 개발자는 서버 설정에 대한 걱정 없이 애플리케이션 로직에 집중할 수 있습니다.

따라서 이 두 프레임워크의 주요 차이점은 Spring Boot가 빠른 프로토타이핑과 개발을 위한 간편한 설정, 내장된 서버, 기본값을 제공한다는 것입니다. 반면 Spring Framework는 개발자가 설정을 완전히 제어하고자 하는 경우 더 좋은 선택일 수 있습니다.


## Springboot의 IoC컨테이너에 대해

---
{: data-content="핵심"}

Spring Boot의 IoC(Inversion of Control) 컨테이너는 객체의 생성, 관리 및 제공을 담당하는 Spring Framework의 핵심 부분입니다. 이 컨테이너는 객체 간의 의존성을 자동으로 관리하며, 이로 인해 개발자는 객체 생성과 의존성 설정에 대한 부담 없이 비즈니스 로직에 집중할 수 있습니다.

---
{: data-content="자세한 설명"}

1. 객체 생성: Spring IoC 컨테이너는 애플리케이션의 시작 시점에 구성 파일(Java Config, XML 등)에 기술된 대로 필요한 객체를 생성합니다. 이렇게 생성된 객체들은 Spring에서는 일반적으로 Bean이라고 부릅니다.

2. 의존성 주입(Dependency Injection): 생성된 객체들이 서로 간에 의존성을 가지는 경우, Spring IoC 컨테이너는 이 의존성을 자동으로 해결합니다. 이를 통해 객체 간의 결합도를 낮추고 코드의 재사용성과 유지 관리성을 높일 수 있습니다. 의존성 주입은 주로 `@Autowired`, `@Resource` 등의 어노테이션을 이용해 이루어집니다.

3. 객체 제공: Spring IoC 컨테이너는 개발자가 필요로 하는 객체를 제공합니다. 이는 주로 ApplicationContext의 `getBean` 메소드를 통해 이루어지며, 필요에 따라 특정 타입의 모든 Bean을 제공하거나 특정 이름의 Bean을 제공할 수 있습니다.

4. 생명주기 관리: Spring IoC 컨테이너는 Bean의 생명주기를 관리합니다. Bean이 생성되고, 의존성이 주입된 후 초기화 메소드가 호출됩니다. 애플리케이션 종료 시에는 소멸 메소드가 호출됩니다. 초기화와 소멸 메소드는 각각 `@PostConstruct`와 `@PreDestroy` 어노테이션을 이용해 지정할 수 있습니다.

따라서, Spring Boot의 IoC 컨테이너는 객체의 생성부터 제거에 이르는 전 과정을 관리하며, 이를 통해 개발자는 객체의 생성과 관리에 들어가는 노력을 절약하고 애플리케이션의 유연성과 확장성을 높일 수 있습니다.


## DI(Dependency Injection)에 대해

---
{: data-content="핵심"}

의존성 주입은 Spring에서 객체 간의 의존 관계를 관리하는 핵심 기능입니다. 이는 클래스 사이의 결합도를 낮추고 코드의 재사용성과 유지 보수성을 향상시키는 기법입니다.

---
{: data-content="자세한 설명"}

DI의 기본 개념은 '의존하는 객체를 직접 생성하는 대신 외부에서 주입 받는다'는 것입니다. 이를 통해 각 클래스는 필요한 의존성만 알면 되며, 어떻게 그 의존성이 만들어지고 조립되는지 알 필요가 없습니다.

예를 들어, 어떤 클래스 A가 클래스 B의 기능을 이용해야 할 때, A가 직접 B를 생성하지 않습니다. 대신에, A의 생성자나 메서드, 혹은 필드를 통해 B의 인스턴스를 주입받습니다.

Spring에서는 이를 위해 IoC 컨테이너가 관리하는 빈들(Bean)을 사용합니다. 빈은 Spring IoC 컨테이너가 관리하는 객체로서, 필요한 곳에 자동으로 주입될 수 있습니다. 이를 통해 개발자는 객체의 생성과 생명주기를 직접 관리하지 않아도 되며, 의존성 관리를 Spring Framework에 위임할 수 있습니다.

이런 방식은 코드의 모듈성과 유연성을 향상시키며, 유닛 테스트를 더 쉽게 만들 수 있습니다. 또한 코드의 결합도를 줄이고, 유지 관리와 코드 재사용성을 향상시키는데 도움이 됩니다.

## @SpringBootApplication에 대해

---
{: data-content="핵심"}

@SpringBootApplication은 Spring Boot 애플리케이션을 구성하는 중요한 어노테이션입니다. 이 어노테이션은 @Configuration, @EnableAutoConfiguration, 그리고 @ComponentScan 세 가지 어노테이션의 기능을 한 번에 제공합니다.

---
{: data-content="자세한 설명"}
@Configuration: 스프링 설정 파일로 작동하게 만드는 어노테이션입니다. 이를 사용하여 스프링 빈을 생성하고 관리할 수 있습니다.

@EnableAutoConfiguration: 스프링 부트의 자동 설정 기능을 활성화합니다. 클래스 경로 설정, 다른 빈들, 다양한 프로퍼티 설정 등을 기반으로 애플리케이션에 필요한 빈들을 자동으로 설정합니다.

@ComponentScan: 이 어노테이션은 @Controller, @Service, @Repository, @Component 등과 같이 스프링에서 관리하는 다른 컴포넌트들을 검색하고 빈으로 등록하도록 합니다.

이 세 가지 어노테이션을 함께 사용하면, Spring Boot 애플리케이션은 최소한의 구성으로도 실행 및 배포가 가능해집니다. @SpringBootApplication 어노테이션은 애플리케이션의 주 클래스에 붙여 사용하며, 이 클래스는 애플리케이션의 root package를 정의하는 데 사용됩니다. 따라서 스프링 부트의 자동 구성 기능이 해당 패키지와 하위 패키지를 스캔하여 빈을 등록하게 됩니다.


## @Resource, @Autowired, @inject의 차이에 대해

---
{: data-content="핵심"}

@Resource, @Autowired, @Inject는 모두 Spring에서 의존성을 주입하는 데 사용되는 어노테이션입니다. 이들은 주입하려는 빈을 찾는 방법과 기본적인 동작이 약간 다릅니다.

---
{: data-content="자세한 설명"}

1. @Autowired: 이 어노테이션은 Spring에서 제공하는 어노테이션으로 주로 타입에 의한 의존성 주입을 지원합니다. 만약 같은 타입의 빈이 여러 개 존재하면 이름으로 찾아서 주입합니다. required 속성이 있는데, 기본값은 true로 되어 있습니다. 이는 의존성 주입을 해야 한다는 의미로, Spring 컨테이너에서 해당 타입의 빈을 찾지 못하면 애플리케이션은 시작되지 않습니다.

2. @Inject: 이 어노테이션은 자바의 표준 어노테이션으로, @Autowired와 동일하게 타입에 의한 의존성 주입을 지원합니다. 또한 @Autowired와 마찬가지로 같은 타입의 빈이 여러 개 존재하면 이름으로 찾아서 주입합니다. 하지만 @Autowired와 달리 required 속성이 없습니다.

3. @Resource: 이 어노테이션은 JSR-250 자바 표준으로, 이름에 의한 의존성 주입을 지원합니다. @Resource는 기본적으로 빈의 이름으로 의존성을 주입하려 시도하며, 해당 이름의 빈을 찾지 못하면 타입에 따라 의존성을 주입하려고 합니다.

이 세 어노테이션은 모두 생성자, 필드, 세터 메서드에 사용될 수 있습니다. 어떤 것을 사용할지는 개발자의 선택이지만, 특별한 이유가 없다면 Spring의 @Autowired를 사용하는 것이 일반적인 추천 방법입니다. 다만, 필요에 따라 JSR-330의 @Inject를 사용하거나, 이름 기반의 검색을 원하면 @Resource를 사용할 수 있습니다.


## Spring 애플리케이션 API 요청을 처리하는 과정에 대해
---
{: data-content="핵심"}

Spring은 클라이언트 요청이 들어오면 먼저 Filter를 통과하고, 그 다음으로 Interceptor, 그리고 마지막으로 실제 컨트롤러로 전달되어 요청을 처리합니다.

---
{: data-content="자세한 설명"}

1. 클라이언트로부터 API 요청이 발생하면, 서블릿 컨테이너는 요청을 Spring 애플리케이션으로 전달합니다.

2. Filter 단계: 여기서는 HTTP 요청이나 응답에 대한 전처리 및 후처리를 진행합니다. Filter는 주로 인증, 로깅, 인코딩 등의 크로스 커팅 콘서른에 사용됩니다.

3. Interceptor 단계: Interceptor는 Filter와 비슷하지만, Spring Context에 등록된 빈에 접근할 수 있다는 점에서 차이가 있습니다. 인터셉터는 주로 로깅, 인증, 트랜잭션 처리 등에 사용됩니다.

4. DispatcherServlet: 이것은 Spring MVC의 핵심 구성 요소로, 모든 HTTP 요청과 응답을 관리합니다. DispatcherServlet은 요청을 적절한 컨트롤러로 라우팅하는 역할을 합니다.

5. Controller 단계: DispatcherServlet은 요청을 처리할 적절한 컨트롤러를 찾습니다. 컨트롤러는 요청을 처리하고 API 요청의 경우 컨트롤러는 일반적으로 JSON 형식의 데이터를 생성하고 응답 본문에 직접 씁니다. 

6. 응답 반환: 최종적으로, 응답이 클라이언트에게 전달됩니다. 이 응답은 일반적으로 JSON 형식의 데이터를 포함하며, HTTP 상태 코드와 함께 전달됩니다.


## DispatcherServlet에 대해
---
{: data-content="핵심"}

DispatcherServlet은 Spring MVC에서 핵심 역할을 하는 Front Controller입니다. 모든 클라이언트 요청을 받아 적절한 컨트롤러에게 작업을 위임하는 중심적인 역할을 수행합니다.

---
{: data-content="자세한 설명"}

Spring MVC에서 클라이언트로부터 들어오는 모든 요청은 DispatcherServlet이 처리하게 됩니다. 이러한 구조는 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 합니다. 클라이언트로부터 요청을 받으면, DispatcherServlet은 이 요청을 분석하고 핸들러 매핑을 사용하여 적절한 컨트롤러를 찾습니다.

찾아낸 컨트롤러가 요청을 처리한 후, 결과 데이터와 뷰 이름을 ModelAndView 객체로 반환합니다. DispatcherServlet은 이 정보를 사용하여 ViewResolver를 통해 실제 뷰를 찾아, 해당 뷰에 모델 데이터를 전달하여 클라이언트에게 최종적인 결과를 렌더링합니다.

또한, DispatcherServlet은 Spring의 IoC 컨테이너와 연동되어 작동합니다. 이를 통해 Controller나 Service, Repository 등이 필요로 하는 의존성을 주입(DI) 받을 수 있게 됩니다.

결과적으로 DispatcherServlet은 클라이언트 요청의 생애주기 전반에 걸쳐 핵심적인 역할을 수행하며, 각 요청을 적절한 컨트롤러로 라우팅하고 최종적인 결과를 렌더링하는 과정을 관리합니다.