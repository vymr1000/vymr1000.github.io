<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-25T16:32:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev Ceremony</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Sun Hong Lee</name></author><entry><title type="html">Spring에 관한 필수 지식들</title><link href="http://localhost:4000/spring%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html" rel="alternate" type="text/html" title="Spring에 관한 필수 지식들" /><published>2023-06-29T00:00:00+09:00</published><updated>2023-06-29T00:00:00+09:00</updated><id>http://localhost:4000/spring%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4</id><content type="html" xml:base="http://localhost:4000/spring%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;#spring의-동작과정에-대해&quot;&gt;Spring의 동작과정에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#springboot의-동작과정에-대해&quot;&gt;SpringBoot의 동작과정에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#spring과-springboot의-차이에-대해&quot;&gt;Spring과 SpringBoot의 차이에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#springboot의-ioc컨테이너에-대해&quot;&gt;Springboot의 IoC컨테이너에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#didependency-injection에-대해&quot;&gt;DI(Dependency Injection)에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#springbootapplication에-대해&quot;&gt;@SpringBootApplication에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#resource-autowired-inject의-차이에-대해&quot;&gt;@Resource, @Autowired, @inject의 차이&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#spring-애플리케이션-api-요청을-처리하는-과정에-대해&quot;&gt;API 요청을 처리하는 과정에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#dispatcherservlet에-대해&quot;&gt;DispatcherServlet에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#트랜잭션에-대해&quot;&gt;트랜잭션에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#acid중-consistency일관성에-대해&quot;&gt;ACID중 Consistency(일관성)에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#transactional에-대해&quot;&gt;@Transactional에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#spring-batch의-주요-구성요소에-대해&quot;&gt;Spring Batch의 주요 구성요소에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#spring-batch에서-chunk에-대해&quot;&gt;Spring Batch에서 chunk에 대해&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#spring-batch에서-트랜잭션-관리&quot;&gt;Spring Batch에서 트랜잭션 관리&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spring의-동작과정에-대해&quot;&gt;Spring의 동작과정에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring 애플리케이션이 시작하는 단계는 크게 &lt;strong&gt;설정 파일 로드&lt;/strong&gt;, &lt;strong&gt;IoC 컨테이너 초기화&lt;/strong&gt;, &lt;strong&gt;Bean 생성 및 등록&lt;/strong&gt;으로 나눌 수 있습니다. 이 과정은 Spring 프레임워크가 개발자 대신 객체의 생명 주기와 의존성을 관리하는 IoC을 구현하는 것입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Spring Framework의 실행 단계는 다음과 같습니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;설정 파일 로드: 애플리케이션이 시작하면 먼저 Spring IoC 컨테이너는 설정 파일을 로드합니다. 이 설정 파일은 XML이거나 Java Config 등 다양한 형식이 될 수 있습니다. 설정 파일은 애플리케이션의 구성 요소인 Bean들과 이들의 의존성을 정의합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IoC 컨테이너 초기화 및 Bean 생성: 설정 파일이 로드되면 IoC 컨테이너는 Bean 정의를 읽어들여 필요한 객체를 생성합니다. 이때 생성된 객체는 해당 Bean 정의에 따른 속성값과 의존성을 가지게 됩니다. 의존성은 다른 Bean들로부터 주입(Dependency Injection)받습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bean 등록 및 사용 준비: IoC 컨테이너는 생성된 Bean을 내부의 Bean 팩토리나 Bean 컨텍스트 등에 등록합니다. 이렇게 등록된 Bean은 애플리케이션의 다른 부분에서 필요할 때 IoC 컨테이너로부터 요청받아 사용될 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 과정들이 완료되면, Spring 애플리케이션이 정상적으로 작동할 수 있는 상태가 됩니다. 이는 Spring의 핵심 원칙인 IoC를 실현하는 과정으로, 개발자는 복잡한 객체 생성과 관리, 의존성 주입 과정을 Spring 프레임워크에 맡김으로써 비즈니스 로직에 집중할 수 있게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;springboot의-동작과정에-대해&quot;&gt;SpringBoot의 동작과정에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;SpringBoot 애플리케이션과 Spring 애플리케이션의 시작 단계는 기본적으로 동일하나, &lt;strong&gt;SpringBoot는 추가적인 자동 구성(자동 설정), 내장 서버&lt;/strong&gt; 등의 기능을 제공하여 초기 구성을 보다 간편하게 합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;SpringBoot의 실행 단계는 다음과 같습니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;설정 파일 로드: 둘 다 설정 파일을 로드하는 것은 같으나, SpringBoot는 Spring의 복잡한 XML 설정을 대체하는 자바 기반의 구성을 선호하며, ‘starters’ 라는 의존성 집합을 이용하여 추가적인 설정 없이 필요한 라이브러리들을 쉽게 포함시킬 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IoC 컨테이너 초기화 및 Bean 생성: SpringBoot 애플리케이션은 Spring 애플리케이션과 같이 IoC 컨테이너를 초기화하고, Bean을 생성합니다. 하지만 SpringBoot는 추가적으로 ‘자동 구성’ 기능을 제공합니다. 이 기능을 통해 SpringBoot는 클래스 경로 설정, 다른 Bean들, 다양한 프로퍼티 설정 등을 기반으로 자동으로 Bean을 구성하고 생성할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내장 서버: Spring 애플리케이션은 외부 서버에 배포되어 실행되는 반면, SpringBoot는 톰캣 같은 내장 서버를 제공하여 별도의 서버 없이도 독립적으로 실행될 수 있습니다. 이를 통해 개발 및 테스트 과정을 간소화하고 빠르게 애플리케이션을 실행시킬 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서, SpringBoot는 Spring 프레임워크의 기본 원칙을 그대로 유지하면서, 개발 및 배포 과정을 간편하게 해주는 여러 추가 기능을 제공합니다. 이로 인해 개발자는 복잡한 설정 과정을 크게 단순화하고, 비즈니스 로직에 더욱 집중할 수 있게 되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;spring과-springboot의-차이에-대해&quot;&gt;Spring과 SpringBoot의 차이에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring과 Spring Boot의 기본적인 차이는 &lt;strong&gt;설정과 간소화&lt;/strong&gt;입니다. Spring Boot는 Spring 기반 애플리케이션을 빠르고 쉽게 구축할 수 있는 미리 설정된 기본 설정을 제공합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;
&lt;p&gt;Spring Framework는 대규모 Java 애플리케이션을 개발하는 데 널리 사용되는 오픈 소스 프레임워크입니다. 이는 IoC(Inversion of Control)와 DI(Dependency Injection)와 같은 강력한 기능을 제공하며, 데이터 액세스, 트랜잭션 관리, MVC 웹 애플리케이션 개발, 쉽게 사용 가능한 보안 구성 등과 같은 다양한 모듈을 제공합니다.&lt;/p&gt;

&lt;p&gt;그러나 Spring Framework를 사용하여 애플리케이션을 설정하고 부트스트랩하는 과정은 복잡할 수 있습니다. 다양한 모듈을 수동으로 설정하고, 데이터 소스, 뷰 리졸버, 메시지 소스 등을 구성하고 관리해야 합니다.&lt;/p&gt;

&lt;p&gt;이러한 복잡성을 해결하기 위해 Spring Boot가 만들어졌습니다. Spring Boot는 단독 실행 가능한 애플리케이션을 생성하는 방법, 즉 ‘spring을 위한 spring’을 제공하며, 개발자가 애플리케이션을 빠르게 시작하고 실행할 수 있도록 지원합니다. Spring Boot는 ‘opinionated defaults’를 제공하여 개발자가 설정을 최소화하고 빠르게 개발에 집중할 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;Spring Boot는 또한 기본값이 설정된 내장된 서버(예: Tomcat, Jetty)를 제공하여 개발자가 쉽게 웹 애플리케이션을 빌드하고 배포할 수 있게 합니다. 이로 인해 개발자는 서버 설정에 대한 걱정 없이 애플리케이션 로직에 집중할 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 이 두 프레임워크의 주요 차이점은 Spring Boot가 빠른 프로토타이핑과 개발을 위한 간편한 설정, 내장된 서버, 기본값을 제공한다는 것입니다. 반면 Spring Framework는 개발자가 설정을 완전히 제어하고자 하는 경우 더 좋은 선택일 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;springboot의-ioc컨테이너에-대해&quot;&gt;Springboot의 IoC컨테이너에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring Boot의 IoC(Inversion of Control) 컨테이너는 &lt;strong&gt;객체의 생성, 의존성 관리 및 제공&lt;/strong&gt;을 담당하는 Spring Framework의 핵심 부분입니다. 이 컨테이너는 객체 간의 의존성을 자동으로 관리하며, 이로 인해 개발자는 객체 생성과 의존성 설정에 대한 부담 없이 비즈니스 로직에 집중할 수 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;객체 생성: Spring IoC 컨테이너는 애플리케이션의 시작 시점에 구성 파일(Java Config, XML 등)에 기술된 대로 필요한 객체를 생성합니다. 이렇게 생성된 객체들은 Spring에서는 일반적으로 Bean이라고 부릅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의존성 주입(Dependency Injection): 생성된 객체들이 서로 간에 의존성을 가지는 경우, Spring IoC 컨테이너는 이 의존성을 자동으로 해결합니다. 이를 통해 객체 간의 결합도를 낮추고 코드의 재사용성과 유지 관리성을 높일 수 있습니다. 의존성 주입은 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 등의 어노테이션을 이용해 이루어집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체 제공: Spring IoC 컨테이너는 개발자가 필요로 하는 객체를 제공합니다. 이는 주로 ApplicationContext의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean&lt;/code&gt; 메소드를 통해 이루어지며, 필요에 따라 특정 타입의 모든 Bean을 제공하거나 특정 이름의 Bean을 제공할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생명주기 관리: Spring IoC 컨테이너는 Bean의 생명주기를 관리합니다. Bean이 생성되고, 의존성이 주입된 후 초기화 메소드가 호출됩니다. 애플리케이션 종료 시에는 소멸 메소드가 호출됩니다. 초기화와 소멸 메소드는 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PostConstruct&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PreDestroy&lt;/code&gt; 어노테이션을 이용해 지정할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서, Spring Boot의 IoC 컨테이너는 객체의 생성부터 제거에 이르는 전 과정을 관리하며, 이를 통해 개발자는 객체의 생성과 관리에 들어가는 노력을 절약하고 애플리케이션의 유연성과 확장성을 높일 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;didependency-injection에-대해&quot;&gt;DI(Dependency Injection)에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;의존성 주입은 Spring에서 객체 간의 &lt;strong&gt;의존 관계를 정의&lt;/strong&gt;하는 핵심 기능입니다. 이는 클래스 사이의 결합도를 낮추고 코드의 재사용성과 유지 보수성을 향상시키는 기법입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;DI의 기본 개념은 ‘의존하는 객체를 직접 생성하는 대신 외부에서 주입 받는다’는 것입니다. 이를 통해 각 클래스는 필요한 의존성만 알면 되며, 어떻게 그 의존성이 만들어지고 조립되는지 알 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 어떤 클래스 A가 클래스 B의 기능을 이용해야 할 때, A가 직접 B를 생성하지 않습니다. 대신에, A의 생성자나 메서드, 혹은 필드를 통해 B의 인스턴스를 주입받습니다.&lt;/p&gt;

&lt;p&gt;Spring에서는 이를 위해 IoC 컨테이너가 관리하는 빈들(Bean)을 사용합니다. 빈은 Spring IoC 컨테이너가 관리하는 객체로서, 필요한 곳에 자동으로 주입될 수 있습니다. 이를 통해 개발자는 객체의 생성과 생명주기를 직접 관리하지 않아도 되며, 의존성 관리를 Spring Framework에 위임할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이런 방식은 코드의 모듈성과 유연성을 향상시키며, 유닛 테스트를 더 쉽게 만들 수 있습니다. 또한 코드의 결합도를 줄이고, 유지 관리와 코드 재사용성을 향상시키는데 도움이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;springbootapplication에-대해&quot;&gt;@SpringBootApplication에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;@SpringBootApplication은 Spring Boot 애플리케이션을 구성하는 중요한 어노테이션입니다. 이 어노테이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableAutoConfiguration&lt;/code&gt;, 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt; 세 가지 어노테이션의 기능을 한 번에 제공합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;
&lt;p&gt;@Configuration: 스프링 설정 파일로 작동하게 만드는 어노테이션입니다. 이를 사용하여 스프링 빈을 생성하고 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;@EnableAutoConfiguration: 스프링 부트의 자동 설정 기능을 활성화합니다. 클래스 경로 설정, 다른 빈들, 다양한 프로퍼티 설정 등을 기반으로 애플리케이션에 필요한 빈들을 자동으로 설정합니다.&lt;/p&gt;

&lt;p&gt;@ComponentScan: 이 어노테이션은 @Controller, @Service, @Repository, @Component 등과 같이 스프링에서 관리하는 다른 컴포넌트들을 검색하고 빈으로 등록하도록 합니다.&lt;/p&gt;

&lt;p&gt;이 세 가지 어노테이션을 함께 사용하면, Spring Boot 애플리케이션은 최소한의 구성으로도 실행 및 배포가 가능해집니다. @SpringBootApplication 어노테이션은 애플리케이션의 주 클래스에 붙여 사용하며, 이 클래스는 애플리케이션의 root package를 정의하는 데 사용됩니다. 따라서 스프링 부트의 자동 구성 기능이 해당 패키지와 하위 패키지를 스캔하여 빈을 등록하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;resource-autowired-inject의-차이에-대해&quot;&gt;@Resource, @Autowired, @inject의 차이에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;는 모두 Spring에서 의존성을 주입하는 데 사용되는 어노테이션입니다. 이들은 주입하려는 빈을 찾는 방법과 기본적인 동작이 약간 다릅니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;@Autowired: 이 어노테이션은 Spring에서 제공하는 어노테이션으로 주로 &lt;strong&gt;타입&lt;/strong&gt;에 의한 의존성 주입을 지원합니다. 만약 같은 타입의 빈이 여러 개 존재하면 &lt;strong&gt;이름&lt;/strong&gt;으로 찾아서 주입합니다. required 속성이 있는데, 기본값은 true로 되어 있습니다. 이는 의존성 주입을 해야 한다는 의미로, Spring 컨테이너에서 해당 타입의 빈을 찾지 못하면 애플리케이션은 시작되지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Inject: 이 어노테이션은 자바의 표준 어노테이션으로, &lt;strong&gt;@Autowired와 동일하게 타입&lt;/strong&gt;에 의한 의존성 주입을 지원합니다. 또한 @Autowired와 마찬가지로 같은 타입의 빈이 여러 개 존재하면 &lt;strong&gt;이름&lt;/strong&gt;으로 찾아서 주입합니다. 하지만 @Autowired와 달리 required 속성이 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Resource: 이 어노테이션은 JSR-250 자바 표준으로, &lt;strong&gt;이름&lt;/strong&gt;에 의한 의존성 주입을 지원합니다. @Resource는 기본적으로 빈의 &lt;strong&gt;이름&lt;/strong&gt;으로 의존성을 주입하려 시도하며, 해당 이름의 빈을 찾지 못하면 &lt;strong&gt;타입&lt;/strong&gt;에 따라 의존성을 주입하려고 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 세 어노테이션은 모두 생성자, 필드, 세터 메서드에 사용될 수 있습니다. 어떤 것을 사용할지는 개발자의 선택이지만, 특별한 이유가 없다면 Spring의 @Autowired를 사용하는 것이 일반적인 추천 방법입니다. 다만, 필요에 따라 JSR-330의 @Inject를 사용하거나, 이름 기반의 검색을 원하면 @Resource를 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;spring-애플리케이션-api-요청을-처리하는-과정에-대해&quot;&gt;Spring 애플리케이션 API 요청을 처리하는 과정에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring은 클라이언트 요청이 들어오면 먼저 Filter를 통과하고, DispatcherServlet, Interceptor 등 여러 요소를 거쳐 실제 Controller로 전달되어 요청을 처리합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;클라이언트로부터 요청이 들어오면, 먼저 Servlet Container가 이를 받습니다. 이 때, 가장 먼저 거치는 것이 Filter입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Filter: 여기서는 HTTP 요청이나 응답에 대한 전처리 및 후처리를 진행합니다. Filter는 주로 인증, 로깅, 인코딩 등의 크로스 커팅 콘서른에 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet: Filter를 거친 요청은 DispatcherServlet에게 전달됩니다. DispatcherServlet는 Front Controller 패턴을 구현한 핵심 컴포넌트로, 요청을 적절한 컨트롤러에게 라우팅하는 역할을 담당합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Interceptor: DispatcherServlet이 요청을 받으면, 이를 처리하기 위해 HandlerMapping을 사용해 해당 요청을 처리할 Controller를 찾습니다. 찾은 Controller에게 요청을 위임하기 전에 Interceptor가 동작하게 됩니다. Interceptor는 AOP(Aspect Oriented Programming)의 일환으로, Controller의 동작 전후에 특정 로직을 실행하게 해주는 역할을 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controller: DispatcherServlet은 요청을 처리할 적절한 컨트롤러를 찾습니다. 컨트롤러는 요청을 처리하고 API 요청의 경우 컨트롤러는 일반적으로 JSON 형식의 데이터를 생성하고 응답 본문에 직접 씁니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응답 반환: 최종적으로, 응답이 클라이언트에게 전달됩니다. 이 응답은 일반적으로 JSON 형식의 데이터를 포함하며, HTTP 상태 코드와 함께 전달됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dispatcherservlet에-대해&quot;&gt;DispatcherServlet에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;DispatcherServlet은 Spring MVC에서 핵심 역할을 하는 Front Controller입니다. &lt;strong&gt;모든 클라이언트 요청을 받아 적절한 컨트롤러에게 작업을 위임&lt;/strong&gt;하는 중심적인 역할을 수행합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Spring MVC에서 클라이언트로부터 들어오는 모든 요청은 DispatcherServlet이 처리하게 됩니다. 이러한 구조는 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 합니다. 클라이언트로부터 요청을 받으면, DispatcherServlet은 이 요청을 분석하고 핸들러 매핑을 사용하여 적절한 컨트롤러를 찾습니다.&lt;/p&gt;

&lt;p&gt;찾아낸 컨트롤러가 요청을 처리한 후, 결과 데이터와 뷰 이름을 ModelAndView 객체로 반환합니다. DispatcherServlet은 이 정보를 사용하여 ViewResolver를 통해 실제 뷰를 찾아, 해당 뷰에 모델 데이터를 전달하여 클라이언트에게 최종적인 결과를 렌더링합니다.&lt;/p&gt;

&lt;p&gt;또한, DispatcherServlet은 Spring의 IoC 컨테이너와 연동되어 작동합니다. 이를 통해 Controller나 Service, Repository 등이 필요로 하는 의존성을 주입(DI) 받을 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;결과적으로 DispatcherServlet은 클라이언트 요청의 생애주기 전반에 걸쳐 핵심적인 역할을 수행하며, 각 요청을 적절한 컨트롤러로 라우팅하고 최종적인 결과를 렌더링하는 과정을 관리합니다.&lt;/p&gt;

&lt;h2 id=&quot;트랜잭션에-대해&quot;&gt;트랜잭션에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;트랜잭션은 &lt;strong&gt;데이터베이스의 상태&lt;/strong&gt;를 변환시키는 하나 이상의 연산들의 집합으로, 이들 연산들은 한꺼번에 수행되거나 전혀 수행되지 않아야 함을 보장하는 기능입니다. 이는 데이터베이스의 일관성을 보장하는 중요한 메커니즘입니다. 트랜잭션의 주요 특성은 &lt;strong&gt;ACID(Atomicity, Consistency, Isolation, Durability)로 요약&lt;/strong&gt;됩니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Atomicity(원자성): 트랜잭션 내의 모든 연산은 한꺼번에 수행되거나 아예 수행되지 않아야 합니다. 즉, 트랜잭션의 연산은 부분적으로 실행되지 않음을 보장합니다.&lt;/p&gt;

&lt;p&gt;Consistency(일관성): 일관성은 트랜잭션 실행 전과 후의 데이터 상태가 일관되게 유지된다는 것을 보장합니다. 즉, 트랜잭션이 일어난 이후의 데이터베이스는 &lt;strong&gt;데이터베이스의 제약이나 규칙을 만족&lt;/strong&gt;해야 한다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;Isolation(독립성): 동시에 수행되는 여러 트랜잭션들이 서로에게 영향을 주지 않음을 보장합니다. 각 트랜잭션은 독립적인 수행을 완료하고, 다른 트랜잭션의 중간 결과를 볼 수 없습니다.&lt;/p&gt;

&lt;p&gt;Durability(영속성): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 합니다. 시스템 장애가 발생해도 이는 보장되어야 합니다.&lt;/p&gt;

&lt;p&gt;이렇게 트랜잭션이 ACID 속성을 통해 데이터의 일관성을 보장하며, 이는 데이터베이스 시스템에서 매우 중요한 역할을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;acid중-consistency일관성에-대해&quot;&gt;ACID중 Consistency(일관성)에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;일관성이란 트랜잭션이 데이터 무결성에 대한 제약 조건을 만족되어야 함을 의미합니다. 즉, 데이터는 모순이 없어야 합니다. 트랜잭션이 제약 조건을 위반하는 경우 일관성을 통해 트랜잭션이 실행되지 않고 이전의 상태로 롤백됩니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;
&lt;p&gt;일관성에 대해 더 자세히 이해하기 위해 예를 들어보겠습니다. 데이터베이스에 “모든 사용자는 이메일 주소를 가져야 한다”는 무결성 제약 조건이 있다고 가정해봅시다. 새 사용자를 생성하는 트랜잭션은 이메일 주소를 제공하지 않으면 실패해야 합니다. 트랜잭션이 성공적으로 완료된 후에는 모든 사용자가 여전히 이메일 주소를 가지고 있어야 하므로 데이터베이스는 일관된 상태를 유지합니다. 이와 같이 일관성은 데이터베이스의 무결성 제약 조건을 유지하면서 트랜잭션의 실행을 보장하는 속성입니다.&lt;/p&gt;

&lt;h2 id=&quot;transactional에-대해&quot;&gt;@Transactional에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt; 어노테이션이 붙은 메소드는 &lt;strong&gt;Spring의 AOP 프록시&lt;/strong&gt;를 통해 트랜잭션 관리가 수행됩니다. 이 프록시는 메소드 호출을 가로채서 트랜잭션 관련 로직을 적용한 후 원래의 메소드를 호출하는 역할을 합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Spring의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt; 어노테이션은 내부적으로 AOP를 활용해 동작합니다. 이때 사용되는 주요 컴포넌트는 TransactionInterceptor와 ProxyFactoryBean입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Proxy 생성: 먼저, Spring IoC 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt; 어노테이션이 붙은 Bean을 실제 객체가 아닌 Proxy로 감싸서 관리합니다. 이 프록시는 &lt;strong&gt;JDK Dynamic Proxy나 CGLIB Proxy&lt;/strong&gt; 등을 사용할 수 있으며, 이는 설정 및 상황에 따라 달라집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메소드 호출: 클라이언트로부터 메소드 호출이 발생하면, 프록시는 실제 객체의 메소드를 직접 호출하는 대신 TransactionInterceptor를 통해 호출합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트랜잭션 시작: TransactionInterceptor는 TransactionManager를 사용하여 트랜잭션을 시작합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실제 메소드 호출: 트랜잭션이 시작되면, 실제 비즈니스 로직을 담은 메소드가 실행됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트랜잭션 종료: 메소드 실행 후, TransactionInterceptor는 트랜잭션을 커밋하거나 롤백합니다. 이때 메소드 실행 도중 예외가 발생하면 롤백, 그렇지 않으면 커밋이 수행됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 Spring의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;은 AOP와 프록시를 통해 선언적 트랜잭션 관리를 제공합니다. 이 방식은 개발자가 직접적으로 트랜잭션을 관리하는 코드를 작성하지 않아도 되게 하므로, 비즈니스 로직에만 집중할 수 있게 해줍니다. 또한, 코드의 가독성을 향상시키고 트랜잭션 관리의 일관성을 보장하는 데에도 도움이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;spring-batch의-주요-구성요소에-대해&quot;&gt;Spring Batch의 주요 구성요소에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring Batch는 대량 데이터 처리를 지원하는 스프링 프레임워크의 부분이며, 주요 구성요소로는 &lt;strong&gt;Job, Step, ItemReader, ItemProcessor, ItemWriter&lt;/strong&gt;가 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Job: Spring Batch의 핵심 API로써, 배치 처리 과정을 나타내는 객체입니다. 일반적으로 하나의 Job은 하나의 배치 작업을 나타내며, 여러 Step 인스턴스로 구성됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step: Step은 Job을 구성하는 독립적인 단계를 나타냅니다. 각 Step은 ItemReader, ItemProcessor, 그리고 ItemWriter를 가지며, 이들을 순차적으로 실행합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ItemReader: 데이터를 읽어오는 역할을 합니다. 파일, 데이터베이스, API 등 다양한 방식으로 데이터를 읽어올 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ItemProcessor: ItemReader를 통해 읽어온 데이터를 처리하는 역할을 합니다. 데이터 필터링, 변환 등의 로직을 이 곳에서 구현합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ItemWriter: 처리된 데이터를 최종적으로 쓰는 역할을 합니다. 데이터베이스, 파일, 메시지 큐 등 다양한 방식으로 데이터를 쓸 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JobLauncher는 Job을 실행하는 API를 제공하며, JobRepository는 배치 처리 상태 및 메타데이터를 관리합니다. Job과 Step은 순차적 또는 병렬로 실행될 수 있으며, 재시작, 건너뛰기, 재시도 등 다양한 배치 처리 전략을 지원합니다.&lt;/p&gt;

&lt;h2 id=&quot;spring-batch에서-chunk에-대해&quot;&gt;Spring Batch에서 chunk에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring Batch에서 청크(chunk) 처리는 대량의 데이터를 일정량 단위로 나눠 처리하는 전략입니다. ItemReader에서 데이터를 읽어온 후 ItemProcessor에서 처리하고, ItemWriter로 데이터를 쓰는 일련의 과정을 청크 단위로 수행합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;청크(chunk) 방식의 처리는 대량의 데이터를 한 번에 처리하기보다는 작은 단위로 나눠서 처리하는 방식을 말합니다. 이는 메모리 이슈를 방지하고, 처리 실패 시에도 일정 단위로만 롤백을 수행해 효율적인 데이터 처리가 가능합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 청크 크기를 1000으로 설정하면 ItemReader는 1000개의 레코드를 읽어옵니다. 이후, 각 레코드에 대해 ItemProcessor가 처리를 수행하고, 이 처리 결과를 다시 ItemWriter가 한 번에 데이터베이스에 반영합니다. 이렇게 1000개의 레코드를 처리하는 것을 하나의 청크로 보며, 이러한 청크를 처리하는 과정이 반복됩니다.&lt;/p&gt;

&lt;p&gt;이 방식은 대용량 데이터를 처리해야 하거나, 특정 작업을 병렬로 수행해야 할 때 유용합니다. 청크 단위로 데이터를 나누어 처리함으로써, 특정 청크에서 오류가 발생하더라도 해당 청크만 롤백하고 다음 청크의 처리를 계속 진행할 수 있기 때문입니다. 이를 통해 전체 작업의 안정성과 효율성을 높일 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;spring-batch에서-트랜잭션-관리&quot;&gt;Spring Batch에서 트랜잭션 관리&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Spring Batch에서의 트랜잭션 관리는 청크 단위로 이루어집니다. 각 청크는 자체 트랜잭션 경계를 가지며, 하나의 청크 내에서 발생하는 모든 작업은 단일 트랜잭션 내에서 처리됩니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Spring Batch에서는 청크를 처리하는 동안 데이터 읽기, 처리, 쓰기의 세 단계를 거칩니다. 이 세 단계는 모두 같은 트랜잭션에 포함되어 있으므로, 이 중 어느 하나가 실패하면 그 청크의 전체 작업이 롤백되고 다시 시작됩니다.&lt;/p&gt;

&lt;p&gt;또한, Spring Batch는 재시작 가능성이라는 중요한 특징을 가지고 있습니다. 청크 단위의 트랜잭션 관리는 이러한 재시작 가능성을 지원하는 핵심 요소 중 하나입니다. 청크 단위로 트랜잭션을 관리하면, 실패한 청크를 쉽게 식별하고 해당 청크부터 재시작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;즉, Spring Batch의 트랜잭션 관리는 청크 단위의 트랜잭션 경계 설정을 통해 안정성과 재시작 가능성을 보장하며, 대용량 데이터 처리를 효율적으로 수행할 수 있도록 지원합니다. 이는 Spring Batch를 통한 배치 처리가 대량의 데이터를 안정적으로 처리해야 하는 많은 비즈니스 케이스에 적합하게 만듭니다.&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2023" /><summary type="html"></summary></entry><entry><title type="html">Java에 관한 필수 지식들</title><link href="http://localhost:4000/java%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html" rel="alternate" type="text/html" title="Java에 관한 필수 지식들" /><published>2023-06-27T00:00:00+09:00</published><updated>2023-06-27T00:00:00+09:00</updated><id>http://localhost:4000/java%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4</id><content type="html" xml:base="http://localhost:4000/java%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;#java-언어의-특징에-대해&quot;&gt;Java 언어의 특징에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#java-프로그램-실행-과정에-대해&quot;&gt;Java 프로그램 실행 과정에 대해&lt;/a&gt;    &lt;br /&gt;
&lt;a href=&quot;#main-메서드에서-static이-생략된다면&quot;&gt;main 메서드에서 static이 생략된다면&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;#jvm의-역할에-대해&quot;&gt;JVM의 역할에 대해&lt;/a&gt;　#JVM &lt;br /&gt;
&lt;a href=&quot;#jvm-메모리-구조에-대해&quot;&gt;JVM 메모리 구조에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#java-stream에-대해&quot;&gt;Java Stream에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#java-stream은-어떤-상황에서-활용될-수-있는가&quot;&gt;Java Stream은 어떤 상황에서 활용될 수 있는가&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#병렬-처리는-언제-적용될-수-있는가&quot;&gt;병렬 처리는 언제 적용될 수 있는가&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#병렬-처리-조건에-해당하는-독립성이란&quot;&gt;병렬 처리 조건에 해당하는 독립성이란&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;java-언어의-특징에-대해&quot;&gt;Java 언어의 특징에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Java는 &lt;strong&gt;객체지향적&lt;/strong&gt;이고, &lt;strong&gt;플랫폼 독립적&lt;/strong&gt;이며, 안정성이 높아 다양한 환경에서 널리 사용되는 프로그래밍 언어입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;객체지향: Java는 완전한 객체지향 프로그래밍 언어입니다. 클래스와 객체를 기반으로 상속, 다형성, 캡슐화와 같은 객체지향의 핵심 개념을 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;플랫폼 독립성: Java의 가장 큰 특징 중 하나는 &lt;strong&gt;Write Once, Run Anywhere&lt;/strong&gt;이라는 원칙을 따르는 것입니다. 즉, Java로 작성된 프로그램은 Java Virtual Machine(JVM)이 설치된 어떤 플랫폼에서도 실행할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;안정성: Java는 컴파일 시간과 실행 시간 모두에 걸쳐 강력한 오류 체크 기능을 제공하여 프로그램의 안정성을 높입니다. 또한, 자동 메모리 관리 기능인 가비지 컬렉션을 지원하여 메모리 누수 문제를 방지합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;멀티스레딩: Java는 내장된 스레딩 기능을 제공하므로 병렬 처리를 통해 프로그램 성능을 향상시킬 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워크 지원: Java는 TCP/IP와 같은 저수준 네트워크 지원부터 HTTP, FTP 등의 고수준 프로토콜 지원에 이르기까지 풍부한 네트워크 프로그래밍 기능을 제공합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;풍부한 라이브러리: Java는 파일 입출력, 데이터베이스 연동, 네트워킹, GUI 등 많은 분야에 걸친 방대한 라이브러리를 제공합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 특징들은 Java가 다양한 환경에서 널리 사용되는 언어가 되게 만들었습니다. Java는 웹 애플리케이션, 모바일 애플리케이션(특히 안드로이드), 임베디드 시스템, 빅데이터 처리 등 다양한 분야에서 활용되며, 이에 걸맞는 다양한 개발 도구와 프레임워크도 풍부하게 제공되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;java-프로그램-실행-과정에-대해&quot;&gt;Java 프로그램 실행 과정에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;자바 프로그램이 실행되는 과정은 크게 소스 코드의 작성, &lt;strong&gt;컴파일&lt;/strong&gt;, &lt;strong&gt;클래스 로드&lt;/strong&gt;, &lt;strong&gt;링크&lt;/strong&gt;, &lt;strong&gt;초기화&lt;/strong&gt;, 그리고 실행 단계로 이루어집니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;소스 코드 작성: 프로그래머는 자바의 문법을 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; 확장자를 가진 자바 소스 코드 파일을 작성합니다.&lt;/li&gt;
  &lt;li&gt;컴파일: 작성된 소스 코드는 자바 컴파일러(‘javac’)에 의해 바이트코드로 변환되며, 이 결과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 확장자를 가진 파일이 생성됩니다. 바이트코드는 플랫폼에 독립적인 코드로서, 모든 환경의 JVM에서 동일하게 실행될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;클래스 로딩: 런타임 시, JVM의 클래스 로더는 필요한 클래스 파일들을 로드합니다. 클래스 로더는 파일 시스템이나 네트워크 등에서 바이트코드가 담긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 파일을 찾아 메모리에 적재하는 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;링크: 로딩된 클래스들은 링크 과정을 거쳐서 JVM이 사용할 수 있는 상태로 준비됩니다. 이 과정은 검증, 준비, 그리고 (선택적으로) 해석 단계를 포함하며, 클래스나 인터페이스의 바이트코드 검증, 정적 변수의 메모리 할당과 초기화, 그리고 바이트코드의 심볼릭 메모리 참조를 메서드 영역의 직접 참조로 변환하는 작업 등을 수행합니다.&lt;/li&gt;
  &lt;li&gt;초기화: 스태틱 변수들이 초기 값으로 대체되고, 스태틱 블록이 실행됩니다. 이 과정은 클래스가 처음으로 활성화 될 때 수행됩니다.&lt;/li&gt;
  &lt;li&gt;실행: JVM의 실행 엔진이 바이트코드를 해석하거나 JIT 컴파일러를 이용해 네이티브 코드로 변환한 후 실행합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 식으로, 자바 프로그램은 작성부터 실행까지 여러 단계를 거치며, 이 각각의 단계에서 발생할 수 있는 오류나 이슈를 이해하고 대응하는 것이 자바 개발자의 중요한 역량 중 하나입니다.&lt;/p&gt;

&lt;h2 id=&quot;main-메서드에서-static이-생략된다면&quot;&gt;main 메서드에서 static이 생략된다면&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Java에서 main 메서드에 static 키워드가 생략된다면, 프로그램은 실행되지 않습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;Java 애플리케이션의 진입점인 &lt;strong&gt;main 메서드는 JVM이 클래스 로딩 없이 호출&lt;/strong&gt;할 수 있어야 합니다. 이를 위해 main 메서드는 static으로 선언되어야 합니다. static 키워드는 메서드가 객체 인스턴스에 속하지 않고 클래스 자체에 속하도록 지정합니다. 따라서 객체를 생성하지 않고도 호출이 가능합니다.&lt;/p&gt;

&lt;p&gt;따라서 main 메서드에 static 키워드가 생략된다면, JVM은 main 메서드를 찾을 수 없게 되므로 프로그램은 시작되지 않습니다. 이때는 “Main method not found in class”라는 오류 메시지가 표시됩니다.&lt;/p&gt;

&lt;p&gt;정리하자면, Java 프로그램의 실행을 위해서는 main 메서드를 static으로 선언해야 하며, 이를 생략하면 프로그램이 실행되지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;jvm의-역할에-대해&quot;&gt;JVM의 역할에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;JVM(Java Virtual Machine)은 자바 바이트코드(.class 파일)를 OS에 특화된 코드로 변환하여 실행하는 역할을 합니다. 이를 통해 자바는 플랫폼 독립적인 언어가 될 수 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;플랫폼 독립성 제공: JVM은 자바 코드가 한번 작성되면 어느 기기에서든 실행될 수 있도록 플랫폼 독립성을 제공합니다. 자바 코드는 JVM이 설치된 어느 플랫폼에서든 실행될 수 있습니다. 이는 자바 코드가 바이트 코드로 컴파일되며, 이 바이트 코드가 JVM 상에서 실행되기 때문입니다. JVM은 이 바이트 코드를 해당 플랫폼의 기계어로 변환하므로, 개발자는 플랫폼에 따라 코드를 다르게 작성할 필요가 없습니다.&lt;/li&gt;
  &lt;li&gt;메모리 관리: JVM은 자바 애플리케이션의 메모리 관리를 담당합니다. JVM은 가비지 컬렉션을 통해 동적 메모리 할당 및 해제를 관리하므로, 개발자는 메모리 관리에 대해 걱정할 필요가 없습니다. 이를 통해 메모리 누수와 같은 문제를 방지하며, 개발자가 보다 비즈니스 로직에 집중할 수 있도록 돕습니다.&lt;/li&gt;
  &lt;li&gt;보안 제공: JVM은 클래스 로더와 바이트 코드 검증기를 통해 자바 애플리케이션의 보안을 관리합니다. 부적절한 코드나 메모리 접근을 방지하여 안전한 실행 환경을 제공합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결국, JVM의 역할은 자바가 &lt;strong&gt;한 번 작성하면 어디서든 실행 가능(Write Once, Run Anywhere)&lt;/strong&gt; 라는 원칙을 이룰 수 있도록 해줍니다. 이는 개발자가 다양한 플랫폼에서 동일하게 작동하는 애플리케이션을 더 쉽게 개발할 수 있게 해줍니다.&lt;/p&gt;

&lt;h2 id=&quot;jvm-메모리-구조에-대해&quot;&gt;JVM 메모리 구조에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;JVM(Java Virtual Machine)의 메모리 구조는 주로 메소드 영역, 힙 영역, 스택 영역, PC 레지스터, 그리고 네이티브 메소드 스택으로 구성되어 있습니다. 각 영역은 JVM이 프로그램을 실행하는 데 필요한 데이터를 저장하고 관리합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;메소드 영역(Method Area): JVM이 읽어 들인 각 클래스와 인터페이스에 대한 런타임 상수 풀, &lt;strong&gt;필드와 메소드 데이터&lt;/strong&gt;, 메소드와 생성자의 바이트코드, 그리고 &lt;strong&gt;static 변수&lt;/strong&gt; 등의 데이터를 저장합니다.&lt;/li&gt;
  &lt;li&gt;힙 영역(Heap Area): 모든 클래스의 인스턴스와 배열이 이 영역에 할당됩니다. 즉, 우리가 &lt;strong&gt;new 키워드를 사용해 생성하는 모든 객체는 이 힙 영역에 생성&lt;/strong&gt;되며, 가비지 컬렉션의 대상이 됩니다.&lt;/li&gt;
  &lt;li&gt;스택 영역(Stack Area): 각 스레드마다 하나씩 존재하며, 메소드의 호출과 과정에서 중간 결과를 저장하고, &lt;strong&gt;메소드가 작업을 수행하는 동안 로컬 변수를 저장&lt;/strong&gt;하는 등의 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;PC 레지스터(PC Register): 현재 수행 중인 JVM 명령의 주소를 저장합니다. 이 레지스터 역시 스레드마다 하나씩 생성됩니다.&lt;/li&gt;
  &lt;li&gt;네이티브 메소드 스택(Native Method Stack): 네이티브 메소드를 위한 스택입니다. 자바 외의 언어로 작성된 네이티브 코드를 위한 공간입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;java-stream에-대해&quot;&gt;Java Stream에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;자바에서 스트림(Stream)은 데이터를 추상화하여 다루는, 데이터의 흐름을 나타내는 객체입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;스트림은 자바 8에서 추가된 기능으로, 복잡한 데이터 처리를 간결하고 효율적으로 할 수 있도록 도와줍니다. 배열이나 컬렉션의 데이터를 함수형 프로그래밍 방식으로 처리할 수 있게 하며, 병렬처리 기능도 지원합니다.&lt;/p&gt;

&lt;p&gt;스트림은 ‘원본 데이터 변경 없이’ 데이터를 처리합니다. 이는 중간 처리 과정에서 새로운 스트림을 생성하면서 원본 데이터를 보호합니다. 또한, 스트림은 ‘게으른 연산’을 통해 필요한 시점에만 데이터를 처리하며, 이는 효율성과 성능 향상에 기여합니다.&lt;/p&gt;

&lt;p&gt;스트림은 크게 ‘중간 연산’과 ‘최종 연산’으로 나뉩니다. 중간 연산은 filter, map 등의 연산을 포함하며, 이는 스트림을 반환하여 연산의 연속성을 보장합니다. 최종 연산은 collect, forEach, reduce 등이 있으며, 스트림을 닫고 결과를 반환하거나 소비하는 연산입니다.&lt;/p&gt;

&lt;p&gt;따라서, 자바의 스트림은 데이터의 흐름을 표현하고, 효율적이고 선언적인 데이터 처리를 가능하게 합니다.&lt;/p&gt;

&lt;h2 id=&quot;java-stream은-어떤-상황에서-활용될-수-있는가&quot;&gt;Java Stream은 어떤 상황에서 활용될 수 있는가&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;자바의 스트림(Stream)은 대용량 데이터 처리, 복잡한 데이터 연산, 병렬처리 등 다양한 상황에서 활용할 수 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;대용량 데이터 처리: 스트림은 대용량의 데이터를 효율적으로 처리하는데 유용합니다. 스트림은 ‘게으른 연산’을 수행하기 때문에, 필요한 시점에서만 데이터를 처리합니다. 따라서 대용량 데이터를 처리할 때 메모리 사용량을 최소화하는 데 도움이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복잡한 데이터 연산: 스트림은 filter, map, reduce 등 다양한 연산을 제공하므로 복잡한 데이터 처리를 쉽게 할 수 있습니다. 이러한 연산들을 사용하면, 데이터 필터링, 변환, 집계 등 복잡한 연산을 선언적으로 수행할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;병렬처리: 스트림은 parallelStream() 메소드를 통해 병렬처리를 지원합니다. 이를 통해 멀티 코어 프로세서의 이점을 최대한 활용하여 성능을 향상시킬 수 있습니다. 하지만 주의할 점은, 모든 작업이 병렬 처리에 적합하지 않으며 공유 변경 가능한 데이터 등에 대한 동기화 문제를 고려해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 자바의 스트림은 대용량 데이터 처리, 복잡한 데이터 연산, 병렬처리 등 다양한 상황에서 활용될 수 있습니다. 그러나 스트림의 특성과 사용 시 주의점을 이해하고 적절한 상황에서 사용해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;병렬-처리는-언제-적용될-수-있는가&quot;&gt;병렬 처리는 언제 적용될 수 있는가&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;웹 애플리케이션에서 병렬처리를 적용하는 것은 작업의 독립성, 데이터의 불변성, 동기화 오버헤드 등을 고려해야 합니다. 적절하게 관리되지 않은 병렬처리는 동시성 문제를 초래하고 성능 저하를 가져올 수 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;작업의 독립성: 병렬 처리는 작업이 독립적일 때 가장 효과적입니다. 즉, 한 작업의 결과가 다른 작업에 영향을 주지 않는 경우입니다. 만약 작업들이 서로 연관되어 있다면, 병렬처리를 통한 성능 향상을 기대하기 어렵습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터의 불변성: 데이터를 병렬로 처리할 때는 해당 데이터가 불변(immutable)한지 확인해야 합니다. 불변 객체를 사용하면 여러 스레드에서 동시에 접근하더라도 문제가 되지 않으므로, 동시성 문제를 피할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동기화 오버헤드: 동기화는 병렬처리에서 동시성 문제를 해결하는 한 가지 방법이지만, 동기화에는 비용이 발생합니다. 따라서 동기화 오버헤드가 작업 처리 시간보다 크다면, 병렬처리보다는 순차 처리가 더 효율적일 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;입출력(IO) 대기 시간: 병렬 처리는 CPU 바운드 작업보다는 IO 바운드 작업에 더 적합합니다. 특히 웹 애플리케이션에서는 외부 서비스 호출, 디스크 입출력 등 IO 대기 시간이 많은 경우, 병렬 처리를 통해 이러한 대기 시간을 최소화할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 웹 애플리케이션에서 병렬처리를 적용하는 것은 상황에 따라 다르며, 위에서 언급한 요소들을 고려하여 결정해야 합니다. 이는 병렬 처리의 이점을 최대화하고, 동시성 문제나 성능 저하 등의 부작용을 최소화하는 데 도움이 될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;병렬-처리-조건에-해당하는-독립성이란&quot;&gt;병렬 처리 조건에 해당하는 독립성이란&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;병렬 처리는 여러 작업을 동시에 처리하는 것을 말합니다. 이 방식은 작업이 서로 독립적일 때 가장 효과적입니다. ‘작업의 독립성’이라는 개념은 한 작업의 결과가 다른 작업에 영향을 미치지 않는 상태를 가리킵니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;병렬 처리에서 독립적인 작업이란 한 작업이 다른 작업의 수행에 영향을 주지 않는 작업을 말합니다. 이런 종류의 작업은 다른 작업의 결과나 상태에 대해 알 필요 없이 각각 독립적으로 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 여러 사진 파일을 동시에 다운로드 받는 작업을 생각해보겠습니다. 각 사진 파일을 다운로드 받는 작업은 서로 독립적입니다. 즉, 한 사진 파일의 다운로드 상태나 속도가 다른 사진 파일의 다운로드에 영향을 주지 않습니다. 따라서 이런 경우에 병렬 처리를 통해 각 사진 파일을 동시에 다운로드 받으면 전체적인 다운로드 시간을 크게 단축시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;반면에, 연산의 결과가 다음 연산의 입력으로 사용되는 경우, 이 작업들은 서로 의존성을 가지게 됩니다. 예를 들어, 피보나치 수열을 계산하는 경우, 각 숫자는 이전 두 숫자의 합으로 계산됩니다. 이러한 작업은 독립적으로 수행될 수 없으므로, 병렬 처리를 적용하더라도 성능 향상을 기대하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;따라서 병렬 처리를 적용할 때는 작업의 독립성을 먼저 고려해야 하며, 작업이 서로 의존성을 가지는지 확인하는 것이 중요합니다. 독립적인 작업들에 대해서만 병렬 처리를 적용하면, 리소스를 효율적으로 활용하여 전체 작업의 수행 시간을 줄일 수 있습니다.&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2023" /><summary type="html"></summary></entry><entry><title type="html">Web에 관한 필수 지식들</title><link href="http://localhost:4000/web%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html" rel="alternate" type="text/html" title="Web에 관한 필수 지식들" /><published>2023-06-21T00:00:00+09:00</published><updated>2023-06-21T00:00:00+09:00</updated><id>http://localhost:4000/web%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4</id><content type="html" xml:base="http://localhost:4000/web%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;— 네트워크    &lt;br /&gt;
&lt;a href=&quot;#http와-https에-대해&quot;&gt;HTTP와 HTTPS에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#쿠키cookie와-세션session에-대해&quot;&gt;쿠키(Cookie)와 세션(Session)에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#rest와-restful-api에-대해&quot;&gt;REST와 RESTful API에 대해&lt;/a&gt;    &lt;br /&gt;
— OS    &lt;br /&gt;
&lt;a href=&quot;#프로세스와-스레드에-대해&quot;&gt;프로세스와 스레드에 대해&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;http와-https에-대해&quot;&gt;HTTP와 HTTPS에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;HTTP(HyperText Transfer Protocol)는 웹에서 데이터를 전송하는 프로토콜입니다. HTTPS(HyperText Transfer Protocol Secure)는 HTTP에 데이터 암호화를 추가한 프로토콜입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;HTTP는 &lt;strong&gt;클라이언트와 서버 간의 요청-응답 프로토콜&lt;/strong&gt;입니다. 클라이언트가 요청을 보내면 서버는 요청된 데이터를 응답으로 보냅니다. 하지만 HTTP는 암호화가 없어 데이터가 네트워크를 통해 전송될 때 제3자에 의해 도청이나 변조될 위험이 있습니다.&lt;/p&gt;

&lt;p&gt;HTTPS는 HTTP와 동일한 요청-응답 방식을 따르지만, SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 전송되는 데이터를 암호화함으로써 보안을 강화합니다. 따라서 HTTPS는 민감한 정보(예: 신용카드 정보, 로그인 자격 증명 등)를 전송할 때 사용되며, HTTP에 비해 보안성이 높습니다.&lt;/p&gt;

&lt;p&gt;HTTPS를 사용하는 웹 사이트는 주소창에 ‘https://’로 시작하며, 대부분의 웹 브라우저는 안전한 연결이 설정된 것을 사용자에게 알리기 위해 락 아이콘이나 다른 시각적 표시를 제공합니다. 이러한 보안 기능 덕분에 HTTPS는 점차 더 많은 웹 사이트에서 기본 프로토콜로 사용되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;쿠키cookie와-세션session에-대해&quot;&gt;쿠키(Cookie)와 세션(Session)에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;쿠키(Cookie)와 세션(Session)은 모두 HTTP 프로토콜의 무상태성을 보완하기 위한 방법입니다. 쿠키는 클라이언트(일반적으로 사용자의 브라우저)에 저장되는 작은 데이터 조각이며, 세션은 서버 측에서 클라이언트를 식별하는데 사용되는 정보입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;HTTP는 무상태(stateless) 프로토콜로, 각각의 요청이 서로 독립적이라는 의미입니다. 이는 서버가 이전 요청의 정보를 기억하지 않음을 의미하며, 따라서 이러한 문제를 해결하기 위해 쿠키와 세션이 도입되었습니다.&lt;/p&gt;

&lt;p&gt;쿠키는 클라이언트 측에 저장되는 작은 텍스트 파일입니다. 웹사이트는 쿠키를 사용하여 사용자에 관한 정보(로그인 정보, 사이트 선호 설정 등)를 기록하고, 사용자가 사이트를 재방문할 때 이 정보를 읽어 사용자 경험을 개인화하는데 사용합니다.&lt;/p&gt;

&lt;p&gt;세션은 서버 측에서 관리되며, 사용자의 요청에 대한 정보를 임시로 저장합니다. 세션 ID는 쿠키를 통해 클라이언트에 전송되어, 서버는 이 ID를 이용해 클라이언트를 식별하고 사용자 세션을 유지합니다.&lt;/p&gt;

&lt;p&gt;이 두 가지 기술의 주요 차이점은 저장 위치와 보안입니다. 쿠키는 클라이언트에 저장되기 때문에 상대적으로 취약할 수 있으나, 세션은 서버 측에서 관리되므로 상대적으로 안전합니다. 그러나 세션은 서버의 리소스를 사용하므로 대량의 사용자가 연결되는 경우 서버에 부하를 줄 수 있습니다. 이러한 특성에 따라 상황에 맞게 쿠키와 세션을 적절하게 사용하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;rest와-restful-api에-대해&quot;&gt;REST와 RESTful API에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;REST(REpresentational State Transfer)는 웹 서비스가 네트워크 상에서 운영되는 방식을 정의한 아키텍처 스타일입니다. RESTful API는 REST 원칙을 따르는 API(Application Programming Interface)를 의미합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;REST는 웹 서비스 간의 통신을 간단하게 만들어 주는 아키텍처 스타일입니다. 이 아키텍처는 네트워크 상의 자원을 유일하게 식별하고, 이들 자원에 대해 CRUD(Create, Read, Update, Delete) 작업을 수행하는데 필요한 표준 HTTP 메서드를 사용하도록 권장합니다.&lt;/p&gt;

&lt;p&gt;RESTful API는 REST 원칙에 따라 설계된 API로, 각 API는 HTTP 메서드와 URL, 그리고 선택적으로 메시지 바디를 사용하여 자원과 상호 작용합니다. RESTful API를 사용하면 개발자는 표준 HTTP 프로토콜을 사용하여 웹 서비스를 쉽게 구축하고, 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, RESTful API를 사용하면 HTTP의 GET 메서드를 사용하여 자원을 조회하고, POST 메서드를 사용하여 새로운 자원을 생성하며, PUT 또는 PATCH 메서드를 사용하여 자원을 업데이트하고, DELETE 메서드를 사용하여 자원을 삭제할 수 있습니다.&lt;/p&gt;

&lt;p&gt;REST 아키텍처를 따르는 시스템은 간단하게 확장할 수 있으며, 독립적으로 진화하고 변경될 수 있습니다. 이는 웹 서비스가 복잡성 없이 커지고 발전하는 데 도움이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;프로세스와-스레드에-대해&quot;&gt;프로세스와 스레드에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;프로세스는 운영 체제에서 실행 중인 프로그램을 나타냅니다. 이는 자체적인 메모리 공간을 갖고 있으며, 시스템 리소스를 활용할 수 있는 독립적인 엔티티입니다.   &lt;br /&gt;
스레드는 프로세스 내에서 실행되는 여러 흐름의 단위입니다. 스레드는 프로세스의 자원을 공유하면서 병렬 처리를 가능하게 합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;프로세스는 각각 독립된 메모리 영역(Code, Data, Stack)과 시스템 자원을 할당받아 사용합니다. 프로세스는 다른 프로세스와 정보를 공유하지 않으며, 프로세스간의 통신(IPC, Inter-Process Communication)을 통해 데이터를 주고 받을 수 있습니다. 운영체제는 프로세스에게 CPU 사용 시간을 할당하고 이를 관리하며, 각 프로세스는 이런 CPU 스케줄링에 따라 동작합니다.&lt;/p&gt;

&lt;p&gt;스레드는 프로세스 내에서 독립적으로 동작하는 여러 실행 흐름이며, 프로세스의 자원과 메모리를 공유합니다. 따라서 스레드간의 통신이 프로세스 간 통신보다 빠르며, 메모리 사용량도 적습니다. 각 스레드는 고유의 Register와 Stack을 갖고 있지만, Heap 메모리는 다른 스레드와 공유합니다. 이를 통해 프로세스 내에서 병렬 처리를 가능하게 하며, 효율적인 프로그램을 작성할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;세마포어에-대해&quot;&gt;세마포어에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;세마포어는 동시에 자원에 접근할 수 있는 프로세스나 스레드의 수를 제한하는 동기화 기법입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;세마포어는 공유 자원에 대한 동시 접근을 제어하는 방법으로, 운영 체제의 커널 영역에서 관리되는 정수값을 이용하여 동작합니다. 이 정수값은 동시에 리소스에 접근할 수 있는 최대 허용 개수를 의미하며, 프로세스 또는 스레드가 자원에 접근하려 할 때 이 값을 감소시키고, 자원 사용이 끝나면 다시 증가시킵니다.&lt;/p&gt;

&lt;p&gt;세마포어의 값이 0이면, 자원에 접근하려는 프로세스나 스레드는 대기 상태로 전환되고, 세마포어의 값이 다시 양수가 될 때까지 대기합니다. 이렇게 함으로써, 공유 자원에 대한 동시 접근을 제어하고 경쟁 상태(race condition)를 방지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;세마포어는 두 가지 기본 연산인 P (proberen, 시도) 연산과 V (verhogen, 증가) 연산으로 이루어져 있습니다. P 연산은 세마포어 값을 감소시키고, V 연산은 값을 증가시키는 작업을 합니다. 이 연산들은 원자적으로 수행되어야 합니다, 즉 이 연산들이 수행되는 동안에는 다른 프로세스나 스레드가 세마포어를 변경하지 못하도록 해야 합니다. 이를 통해 공유 자원에 대한 동기화를 유지하고 데이터의 일관성을 보장합니다.&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스에-대해&quot;&gt;뮤텍스에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;뮤텍스(Mutex, Mutual Exclusion)는 동시에 하나의 스레드 또는 프로세스만이 공유 리소스에 접근하도록 제한하는 동기화 기법입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;뮤텍스는 상호 배제(Mutual Exclusion)의 약어로, 여러 스레드 또는 프로세스가 동시에 공유 리소스에 접근하는 것을 방지하고, 한 번에 하나의 스레드 또는 프로세스만이 해당 자원을 사용하도록 제한합니다. 이렇게 함으로써, 뮤텍스는 동시성 제어와 데드락 방지를 위한 중요한 도구로 작용합니다.&lt;/p&gt;

&lt;p&gt;뮤텍스는 일반적으로 lock과 unlock 연산으로 구성됩니다. lock 연산은 스레드가 공유 자원을 사용하려고 할 때 호출되며, 해당 자원에 대한 뮤텍스가 이미 잠겨있는 경우, 호출한 스레드는 뮤텍스가 해제될 때까지 대기 상태가 됩니다. 반대로 unlock 연산은 스레드가 공유 자원 사용을 완료하면 호출되며, 이 연산은 뮤텍스를 해제하고 다른 스레드가 공유 자원을 사용할 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;다만, 뮤텍스를 사용할 때는 잠금-해제 순서를 잘 관리해야 하며, 그렇지 않으면 데드락(두 개 이상의 프로세스나 스레드가 서로 상대방의 작업이 끝나기를 영원히 기다리는 상태)가 발생할 수 있습니다. 이러한 문제를 방지하기 위해서는 구조적으로 잠금-해제 순서를 잘 디자인하고, 필요한 경우에는 다른 동기화 메커니즘(예: 세마포어나 컨디션 변수 등)과 함께 사용하는 것이 좋습니다.&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2023" /><summary type="html">— 네트워크 HTTP와 HTTPS에 대해 쿠키(Cookie)와 세션(Session)에 대해 REST와 RESTful API에 대해 — OS 프로세스와 스레드에 대해</summary></entry><entry><title type="html">Linux에 관한 필수 지식들</title><link href="http://localhost:4000/linux%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html" rel="alternate" type="text/html" title="Linux에 관한 필수 지식들" /><published>2023-06-20T00:00:00+09:00</published><updated>2023-06-20T00:00:00+09:00</updated><id>http://localhost:4000/linux%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4</id><content type="html" xml:base="http://localhost:4000/linux%EC%97%90-%EA%B4%80%ED%95%9C-%ED%95%84%EC%88%98-%EC%A7%80%EC%8B%9D%EB%93%A4.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;#linux에-대해&quot;&gt;Linux에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#crontab에-대해&quot;&gt;crontab에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#ping과-netstat&quot;&gt;ping과 netstat&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#ssh에-대해&quot;&gt;ssh에 대해&lt;/a&gt;     &lt;br /&gt;
&lt;a href=&quot;#linux-주요-명령어에-대해&quot;&gt;Linux 주요 명령어에 대해&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux에-대해&quot;&gt;Linux에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Linux는 Unix 기반의 무료 오픈 소스 운영 체제입니다. 사용자 커뮤니티의 지원으로 확장성, 보안성, 안정성, 커스터마이즈성 등을 가지고 있습니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;오픈 소스: Linux의 가장 큰 특징 중 하나는 소스 코드가 공개되어 있어 누구나 자유롭게 확인, 수정, 배포할 수 있다는 점입니다. 이로 인해 개발자 커뮤니티가 소프트웨어의 오류를 발견하고 개선하면서 끊임없이 발전해 나갑니다.&lt;/p&gt;

&lt;p&gt;확장성: Linux는 확장성이 매우 높습니다. 이는 기본적인 최소한의 운영 체제 위에서 필요한 컴포넌트만 선택하여 설치할 수 있으므로, 필요에 따라 운영 체제를 경량화하거나 특정한 용도로 확장할 수 있습니다.&lt;/p&gt;

&lt;p&gt;보안: Linux는 사용자 권한과 접근 권한을 철저히 관리함으로써 높은 보안성을 제공합니다. 또한 커뮤니티의 지원을 받아 보안 취약점이 발견되면 신속하게 패치됩니다.&lt;/p&gt;

&lt;p&gt;안정성: Linux는 고도의 안정성을 제공합니다. 장기간에 걸쳐 시스템을 계속 실행하는 서버 환경에서 매우 중요한 요소로, 장애 없이 장시간 동안 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;커스터마이즈: Linux의 또 다른 장점은 사용자가 시스템을 자신의 필요에 맞게 사용자 정의할 수 있다는 것입니다. 이는 그래픽 사용자 인터페이스(GUI) 스타일부터 시스템 운영까지 다양한 수준에서 가능합니다.&lt;/p&gt;

&lt;p&gt;다양한 배포판: Linux는 다양한 ‘배포판’으로 제공되며, 각 배포판은 특정 목표나 목적을 가지고 개발되었습니다. 예를 들어, Ubuntu, Fedora, CentOS, Debian 등은 다양한 환경에 맞게 개발된 배포판입니다.&lt;/p&gt;

&lt;h2 id=&quot;crontab에-대해&quot;&gt;crontab에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;&lt;strong&gt;crontab&lt;/strong&gt;은 UNIX 기반 시스템에서 시간을 기반으로 작업을 스케줄링하는 도구입니다. 이는 주기적으로 실행되어야 하는 작업을 예약하고 관리하는데 사용됩니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;crontab은 &lt;strong&gt;cron table&lt;/strong&gt;의 줄임말로, ‘cron’이라는 데몬이 주기적으로 실행할 작업을 관리합니다. 이를 통해 사용자는 시스템 유지 보수, 데이터 백업, 보고서 생성 등의 작업을 자동으로 수행하도록 예약할 수 있습니다.&lt;/p&gt;

&lt;p&gt;crontab 파일에는 각 줄마다 하나의 작업을 정의하며, 각 줄은 6개의 필드로 구성됩니다. 첫 5개의 필드는 작업이 실행될 시간과 날짜를 지정하고, 마지막 필드에는 실행할 명령을 작성합니다. 시간과 날짜 필드는 분(0-59), 시(0-23), 일(1-31), 월(1-12), 요일(0-7, 0과 7은 일요일) 순서로 구성됩니다.&lt;/p&gt;

&lt;p&gt;crontab에 새 작업을 추가하려면 터미널에서 ‘crontab -e’ 명령을 사용하여 crontab 파일을 열어 수정하면 됩니다. 예를 들어, 매일 오전 5시에 백업 스크립트를 실행하도록 작업을 예약하려면 다음과 같이 작성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 5 * * * /path/to/backup_script.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 설정한 후에는 cron이 자동으로 이 작업을 매일 오전 5시에 실행합니다. ‘crontab -l’ 명령을 사용하면 현재 설정된 모든 cron 작업을 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ping과-netstat&quot;&gt;ping과 netstat&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;&lt;strong&gt;ping&lt;/strong&gt;은 네트워크 연결 상태를 확인하는 도구로, 원격 호스트와의 연결성과 라운드-트립 시간을 확인할 수 있습니다. &lt;strong&gt;netstat&lt;/strong&gt;은 네트워크 연결, 라우팅 테이블, 네트워크 인터페이스 등 네트워크 관련 정보를 보여주는 명령어입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;ping: ‘ping’ 명령어는 ICMP(Internet Control Message Protocol)를 이용해 원격 호스트에 에코 요청 패킷을 보내고 응답을 기다립니다. 원격 호스트가 응답하면 ‘ping’은 라운드-트립 시간(요청을 보낸 후 응답이 돌아오는 시간)과 패킷 손실률 등의 통계를 제공합니다. 이를 통해 네트워크 연결 상태를 확인하고 문제를 진단할 수 있습니다.&lt;/p&gt;

&lt;p&gt;netstat: ‘netstat’ 명령어는 네트워크 연결, 라우팅 테이블, 인터페이스 상태 등 네트워크 상태에 관한 정보를 제공합니다. 이 명령어는 TCP/IP 네트워크 프로토콜 스택의 내부 상태를 표시하여, 어떤 호스트와의 연결이 활성화되어 있는지, 어떤 네트워크 포트가 열려있는지, 데이터가 어떻게 전송되는지 등을 확인할 수 있습니다. 이를 통해 네트워크 성능 문제나 보안 이슈를 진단할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ssh에-대해&quot;&gt;ssh에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;SSH(Secure Shell)는 네트워크 프로토콜 중 하나로, 원격으로 다른 컴퓨터에 안전하게 접속할 수 있는 방법을 제공합니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SSH 클라이언트 설치: Linux 시스템에는 기본적으로 SSH 클라이언트가 설치되어 있지만, Windows의 경우 별도로 SSH 클라이언트를 설치해야 합니다. 윈도우10 이상에서는 OpenSSH가 내장되어 있지만, 그 이전 버전에서는 별도의 SSH 클라이언트 프로그램(예: PuTTY)을 설치해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSH 서버 확인: 원격 접속하려는 Linux 시스템에는 SSH 서버가 실행되고 있어야 합니다. 일반적으로 Linux 배포판에는 SSH 서버가 포함되어 있지만, 실행 상태인지 또는 SSH 접근이 허용되어 있는지 확인해야 합니다. 이는 Linux 시스템의 설정 파일(/etc/ssh/sshd_config)에서 확인하거나, “sudo systemctl status ssh” 명령어를 통해 확인할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSH 접속: SSH 클라이언트를 이용하여 원격 Linux 시스템에 접속할 수 있습니다. 일반적으로 “ssh [사용자명]@[서버의 IP 주소 또는 도메인 이름]” 형식의 명령어를 사용합니다. 예를 들어, 사용자명이 ‘user’, 서버의 IP가 ‘192.168.0.1’인 경우 “ssh user@192.168.0.1”을 입력하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증: SSH 서버에 처음 접속하는 경우, 해당 서버의 공개키가 클라이언트에 저장되고, 이후 접속 시 이를 확인하여 보안을 유지합니다. 사용자명과 비밀번호를 입력하여 인증하거나, 미리 설정된 SSH 키를 통해 인증할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;접속 종료: 원격 작업이 끝난 후에는 ‘exit’ 명령어를 입력하여 SSH 접속을 종료할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;linux-주요-명령어에-대해&quot;&gt;Linux 주요 명령어에 대해&lt;/h2&gt;

&lt;hr data-content=&quot;핵심&quot; /&gt;

&lt;p&gt;Linux 명령어는 터미널에서 Linux 운영 체제를 제어하는 데 사용되는 텍스트 기반 명령어입니다.&lt;/p&gt;

&lt;hr data-content=&quot;자세한 설명&quot; /&gt;

&lt;p&gt;다음은 Linux에서 주로 사용하는 명령어들입니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ls: 현재 디렉토리의 내용을 나열합니다. -l 옵션을 함께 사용하면 자세한 정보(권한, 소유자, 그룹, 크기, 최종 수정 날짜, 파일 이름)를 볼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cd: 디렉토리를 변경하는 데 사용합니다. 예를 들어, cd /home/user/Documents 명령어는 현재 위치를 /home/user/Documents로 변경합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pwd: 현재 디렉토리의 절대 경로를 출력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cat: 파일의 내용을 출력합니다. 여러 파일을 지정하면 이들을 연결하여 출력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rm: 파일이나 디렉토리를 삭제합니다. -r 옵션을 사용하면 디렉토리와 그 하위 내용을 모두 삭제합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cp: 파일이나 디렉토리를 복사합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mv: 파일이나 디렉토리를 이동하거나 이름을 변경합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;touch: 새로운 빈 파일을 생성하거나, 이미 존재하는 파일의 수정 시간을 업데이트합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chmod: 파일이나 디렉토리의 권한을 변경합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sudo: 다른 사용자의 보안 권한(기본적으로는 슈퍼유저)으로 명령을 실행합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;man: 다른 Linux 명령어의 매뉴얼 페이지를 보여줍니다. 예를 들어, man ls를 입력하면 ls 명령어에 대한 상세한 정보를 확인할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Sun Hong Lee</name></author><category term="2023" /><summary type="html"></summary></entry><entry><title type="html">도메인 서비스 &amp;amp; 애플리케이션 서비스</title><link href="http://localhost:4000/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B9%84%EC%8A%A4.html" rel="alternate" type="text/html" title="도메인 서비스 &amp;amp; 애플리케이션 서비스" /><published>2022-09-03T00:00:00+09:00</published><updated>2022-09-03T00:00:00+09:00</updated><id>http://localhost:4000/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-&amp;-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B9%84%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B9%84%EC%8A%A4.html">&lt;p&gt;도메인 서비스는 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;em&gt;value object(VO)&lt;/em&gt;&lt;/strong&gt; 에 자연스럽게 맞지 않는 도메인 정보를 전달한다고 한다. 그러나 도메인 서비스를 도입하려는 또 다른 이유가 있다. 그 이유는 도메인 모델 &lt;strong&gt;격리(Isolation)&lt;/strong&gt; 와 관련이 있다.&lt;/p&gt;

&lt;p&gt;그렇다면, 도메인 서비스와 애플리케이션 서비스의 차이점은 무엇일까. 이 두 개념은 도메인 엔티티와 &lt;strong&gt;&lt;em&gt;value object&lt;/em&gt;&lt;/strong&gt; 위에서 작동할 수 있는 &lt;strong&gt;Stateless class&lt;/strong&gt;를 가정하지만, 유사성은 거의 동일하다. 이들의 주요 차이점은 &lt;strong&gt;도메인 서비스는 도메인 로직을 유지하는 반면 애플리케이션 서비스는 그렇지 않다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도메인 로직은 비즈니스 의사 결정과 관련된 모든 것이다. 그러므로 도메인 서비스는 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;em&gt;value object&lt;/em&gt;&lt;/strong&gt; 가 하는 것과 같은 방식으로 의사 결정 과정에 참여한다. 또한 애플리케이션 서비스는 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;value object&lt;/em&gt;&lt;/strong&gt;의 의사 결정을 조정하는 것과 동일한 방식으로 이러한 의사 결정을 조정한다.&lt;/p&gt;

&lt;p&gt;아래 애플리케이션 서비스의 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 현금 인출 메소드 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;cm&quot;&gt;/* ATM 도메인로직 호출 부 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CalculateAmountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;cm&quot;&gt;/* 비즈니스적 과정에 따른 결과 저장 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_paymentGateway&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ChargePayment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithdrawMoney&lt;/code&gt;방법은 애플리케이션 서비스의 일부이며 사용자 대면 API로 구성된다. ATM &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;에게 먼저 일정량의 돈을 출금하도록 지시한 다음 수수료로 금액을 계산하도록 요청하고 계산 결과를 사용하여 지불 게이트웨이를 통해 지불을 청구하고 마지막으로 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;를 데이터베이스에 저장한다.&lt;/p&gt;

&lt;p&gt;처음 두 줄에서 이 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Atm domain Entity&lt;/code&gt;를 사용하여 몇 가지 비즈니스 결정을 내린다. 마지막 두 줄을 사용하여 비즈니스적 과정의 결과물로 변환한다. 지불 게이트웨이를 호출하고 데이터베이스 상태를 수정하는 것이 그것이다.&lt;/p&gt;

&lt;p&gt;여기에서 처음 두 줄은 의사 결정 프로세스를 도메인 모델에 위임하는 것이다. 하지만 어떤 두 줄의 코드는 그 자체로 도메인 지식을 사용하는 것이 아닌가? 도메인 서비스로 추출해야 하지 않을까?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 변환 후 WithdrawMoney 메서드, 도메인에 대한 내용을 Domain Service에 위임한다 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_atmService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseAndCalculateCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_paymentGateway&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ChargePayment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Domain Service */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtmService&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DispenseAndCalculateCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Atm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CalculateAmountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사실 그렇지 않다. 도메인 모델과 어떻게든 관련이 있는 두 줄 이상의 코드를 사용한다는 사실만으로 도메인 지식이 구성되지 않는다. 중요한 것은 이러한 코드 라인이 비즈니스 의사 결정에 책임이 있는지 여부이다.&lt;/p&gt;

&lt;p&gt;위의 샘플에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispenseAndCalculateCommission&lt;/code&gt; 방법은 순환 복잡도가 1이다. 코드를 신호화하는 분기(문장이 어떤 결정을 내리더라도)는 없고 도메인 엔티티에 두 가지 개별적인 작업을 수행하도록 요청한다.&lt;/p&gt;

&lt;p&gt;이 두 가지 방법이 호출되는 순서도 중요하지 않다. 만약 우리가 그것들을 다시 배열하고 수수료 계산 쿼리를 분배금 명령 위에 두면, ATM의 불변량 측면에서 아무것도 변하지 않을 것이고, 그것은 여전히 유효할 것이다. 구현 세부 정보가 유출되지 않았다는 것은 강력한 신호이기도 합니다.&lt;/p&gt;

&lt;p&gt;이제 코드 샘플을 약간 변경하고 검증도 포함된다고 가정해 보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CanDispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CalculateAmountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_paymentGateway&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ChargePayment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예제의 순환 복잡도는 “if” 문장이 있기 때문에 1보다 높다. 이제 애플리케이션 서비스에 도메인 지식이 포함되어 있다는 뜻 아닐까?&lt;/p&gt;

&lt;p&gt;또한, 아닙니다. 실제 의사 결정 과정은 여전히 ATM에 존재한다. 기업이 돈을 지출할 수 있는지 여부는 기업과 기업만이 결정한다. 애플리케이션 서비스는 해당 결정을 조정하고 실행을 계속할지 여부를 결정합니다.&lt;/p&gt;

&lt;p&gt;ATM의 DispenseMoney 메서드에 현금을 지출하기 전에 CanDispenseMoney가 참이어야 한다는 전제 조건이 있는 한 모든 불변량은 보호 상태를 유지한다. 전제 조건 자체는 다음과 같이 간단하게 구현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CanDispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 애플리케이션 서비스가 캔디스팬스 머니의 결정을 무시하더라도 ATM 주체는 일관성이 없는 상태가 되지 않는다. 따라서 페일패스트 원칙을 고수하는 예외를 던질 것이다.&lt;/p&gt;

&lt;h2 id=&quot;언제-domain-service-를-따로-추출해야-하는가&quot;&gt;언제 Domain Service 를 따로 추출해야 하는가.&lt;/h2&gt;

&lt;p&gt;위의 샘플의 애플리케이션 서비스는 비즈니스 결정을 내리지 않고 도메인 모델에 결정을 위임한다. Atm 엔티티는 데이터베이스에 저장되지 않으며 지불 게이트웨이를 통해 직접 지불을 청구하지 않는다. 비즈니스 로직은 도메인 모델에 귀속되는 반면 외부 세계와의 상호 작용은 애플리케이션 서비스에 귀속된다.&lt;/p&gt;

&lt;p&gt;대부분의 코드베이스에서 이러한 지침을 준수하는 패턴을 볼 수 있다. 실행 흐름은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;strong&gt;Step1,&lt;/strong&gt; Prepare all information needed for a business operation: load participating entities from the database and retrieve any required data from other external sources.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;strong&gt;Step2,&lt;/strong&gt; Execute the operation. The operation consists of one or more business decisions made by the domain model. Those decisions result in either changing the model’s state, generating some artifacts (amountWithCommission value in the sample above), or both.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;strong&gt;Step3,&lt;/strong&gt; Apply the results of the operation to the outside world.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Step1,&lt;/em&gt;&lt;/strong&gt; 비즈니스 운영에 필요한 모든 정보 준비: 데이터베이스에서 참여 엔티티를 로드하고 다른 외부 소스에서 필요한 데이터를 검색한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Step2,&lt;/em&gt;&lt;/strong&gt; 작업을 실행한다. 작업은 도메인 모델에 의해 결정된 하나 이상의 비즈니스 결정으로 구성된다. 이러한 결정으로 인해 모델의 상태가 변경되고 일부 아티팩트가 생성된다(금액). 위의 샘플에서 커미션 값을 사용하거나 둘 다 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Step3,&lt;/em&gt;&lt;/strong&gt; 작업 결과를 외부에 적용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오직 1단계와 3단계만이 외부 의존성이 있는 작업을 포함한다. 2단계는 1단계에서 검색된 데이터에 따라 닫힌다. 인수가 허용하는 인수와 생성되는 출력은 엔티티, 값 개체 및 원시 유형으로만 구성된다.&lt;/p&gt;

&lt;p&gt;단순한 CRUD 애플리케이션에서는 결정을 내릴 수 없기 때문에 두 번째 단계가 없다. 이 경우 모든 작업은 애플리케이션 서비스만 수행할 수 있으므로 도메인 모델에 위임할 필요가 없다. 사실, &lt;strong&gt;&lt;em&gt;Rich&lt;/em&gt;&lt;/strong&gt; 도메인 모델은 있을 수 없다. &lt;strong&gt;&lt;em&gt;Anemic&lt;/em&gt;&lt;/strong&gt; 도메인 모델은 그러한 상황에서 잘 작동할 것이다.&lt;/p&gt;

&lt;p&gt;이제 코드 샘플을 좀 더 현실적인 시나리오로 수정해 보자. 잔액이 부족하여 결제 수수료가 실패할 수 있으며, 그럴 경우 현금을 지급해서는 안 된다고 가정해 보자.&lt;/p&gt;

&lt;p&gt;여기서 위에서 설명한 우려의 멋진 분리가 깨지기 시작한다. 이제 의사 결정 프로세스는 해당 의사 결정 프로세스를 시작할 때까지 사용할 수 없는 정보에 따라 달라진다. 코드는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CanDispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CalculateAmountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_paymentGateway&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ChargePayment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;IsFailure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 버전에서 우리가 소개한 두 번째 if 문은 도메인 로직을 나타낸다. 그것은 우리가 사용자에게 현금을 지급할지 여부를 결정한다. 그러나, 첫 번째 조건부 운영자와 달리, 그러한 결정을 내리는 것은 ATM 주체가 아니다. 애플리케이션 서비스 자체이다.&lt;/p&gt;

&lt;p&gt;그 전에 결제가 실패했더라도 이제는 ATM에서 현금을 인출할 수 있다. 도메인 엔티티는 우리에게 이 불변성을 유지하지 않는다. 그리고 기업의 격리를 위반하지 않고 그러한 불변량을 도입하는 것은 불가능하다. 왜냐하면 이 전제조건을 확인하기 위해서는 제3자 서비스를 호출해야 할 것이기 때문이다.&lt;/p&gt;

&lt;p&gt;그렇다면, 이런 상황에서 어떻게 해야 할까? 이것이 도메인 서비스가 도움이 될 수 있는 부분이다. 외부 세계의 추가 정보를 필요로 하고 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;value objects&lt;/em&gt;&lt;/strong&gt;에 의해 이루어질 수 없는 모든 비즈니스 결정을 그들에게 귀속시킬 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Atm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_atmService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtmService&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Domain service&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WithdrawMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Atm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CanDispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CalculateAmountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_paymentGateway&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ChargePayment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amountWithCommission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;IsFailure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;atm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DispenseMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 도메인 서비스는 불순물과 보유하고 있는 복잡성/비즈니스 논리 사이의 중간 지점이다. 한편으로는, 우리는 이 서비스를 완전히 고립시킬 수 없습니다. 왜냐하면 이 서비스가 일을 하기 위해서는 지불 게이트웨이와 함께 작동해야 하기 때문이다. 반면에, 우리는 너무 많은 도메인 논리를 그것에 돌리지 않고 단지 현금을 신용으로 교환하는 방법에 대한 지식만 돌린다.&lt;/p&gt;

&lt;p&gt;우리는 여전히 가능한 한 많은 논리를 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;에 귀속시킨다. 예를 들어 현금을 분배하는 행위는 여전히 ATM의 책임이다. 그리고 우리는 여전히 가능한 한 도메인 서비스를 격리하려고 노력한다. 예를 들어, 비즈니스 결정을 내릴 필요가 없기 때문에 저장소와 함께 작동하지 않는다. 서비스에 도입된 불순물과 도메인 로직은 여기서 최소한의 것이다. 제대로 작동하기에 충분하다.&lt;/p&gt;

&lt;p&gt;This extraction may look questionable. Isn’t it just a shift of responsibilities with no practical benefits? There are some benefits, however. The code in the domain service is more testable than in the application service. It has fewer external dependencies and therefore we need to use fewer test doubles in order to unit test it. This service is of course not as testable as the entity but still. The second benefit is that this way we prevent domain knowledge leakage and keep all domain logic within the domain model boundary which may be helpful for readability.&lt;/p&gt;

&lt;p&gt;이 추출은 의심스러운 것처럼 보일 수 있다. 실익이 없는 책임 전가 아닌가. 하지만 몇 가지 이점이 있다. 도메인 서비스의 코드는 애플리케이션 서비스보다 더 테스트 가능하다. 외부 의존성이 적기 때문에 단위 테스트를 위해 테스트 더블을 더 적게 사용해야 한다. 이 용역은 물론 기업만큼 시험할 수는 없지만 여전히 유효하다. 두 번째 이점은 이러한 방식으로 도메인 지식 유출을 방지하고 가독성에 도움이 될 수 있는 모든 도메인 논리를 도메인 모델 경계 내에 유지한다는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Domain services carry domain knowledge; application services don’t (ideally).&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Domain services hold domain logic that doesn’t naturally fit entities and value objects.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Introduce domain services when you see that some logic cannot be attributed to an entity/value object because that would break their isolation.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 서비스는 도메인 지식을 전달하지만 애플리케이션 서비스는 그렇지 않다.&lt;/li&gt;
  &lt;li&gt;도메인 서비스는 &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;value object&lt;/em&gt;&lt;/strong&gt;에 자연스럽게 맞지 않는 도메인 로직을 보유한다.&lt;/li&gt;
  &lt;li&gt;일부 논리가 &lt;strong&gt;&lt;em&gt;entity/value object&lt;/em&gt;&lt;/strong&gt;에 귀속될 수 없는 경우 해당 개체 분리가 중단되므로 도메인 서비스를 도입하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://enterprisecraftsmanship.com/posts/domain-vs-application-services/&quot;&gt;Enterprise Craftsmanship: Domain services vs Application services&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html">도메인 서비스는 entity와 value object(VO) 에 자연스럽게 맞지 않는 도메인 정보를 전달한다고 한다. 그러나 도메인 서비스를 도입하려는 또 다른 이유가 있다. 그 이유는 도메인 모델 격리(Isolation) 와 관련이 있다.</summary></entry><entry><title type="html">Concurrency</title><link href="http://localhost:4000/concurrency.html" rel="alternate" type="text/html" title="Concurrency" /><published>2022-08-05T00:00:00+09:00</published><updated>2022-08-05T00:00:00+09:00</updated><id>http://localhost:4000/concurrency</id><content type="html" xml:base="http://localhost:4000/concurrency.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;소스코드의 특정 블럭을 동기화시키고자 할 때, 항상 메모리 가시성(Memory Visibility) 문제가 발생한다. 특정 변수의 값을 사용하고 있을 때 다른 스레드가 그 변수의 값에 접근하지 못하도록 막아야 하는 &lt;strong&gt;상호배제(Mutual exclusion)&lt;/strong&gt; 도 중요하지만 값을 수정한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있어야 하는 &lt;strong&gt;가시성(Visibility)&lt;/strong&gt; 도 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;가시성visibility&quot;&gt;가시성(&lt;strong&gt;Visibility&lt;/strong&gt;)&lt;/h2&gt;

&lt;p&gt;싱글 스레드 환경에서는 프로그램의 코드가 특정 변수에 값을 수정한 다음 다시 그 변수의 값에 접근해보면 이전에 수정한 값을 다시 가져올 수 있다. 멀티 스레드 환경에서는 반드시 수정한 값을 읽는 것이 보장되지는 않는다. 공유 변수에 대해서 어떤 스레드가 값을 수정했을 때, 그 값을 다른 스레드가 읽어갈 수 있다는 보장이 없다. 수정하기 전 변수 값을 읽거나 심지어 값을 읽어가지 못할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/cpu-main-memory.png&quot; width=&quot;400px&quot; /&gt;
멀티프로세서에서 Stale Data 현상&lt;/p&gt;

&lt;p&gt;Thread는 동작하는 시점에 하나의 CPU Core를 점유하고 동작을 한다. 선언한 변수의 값이 Memory에만 존재하는 것이 아니라 CPU Cahce라고 하는 영역에도 존재한다. 이는 CPU가 Memory에서 값을 읽어들여오고 다시 쓰고 하는 시간을 아끼기 위함이다. 더 큰 문제는 CPU Cache에 값이 Memory에 언제 옮겨갈지도 모른다는 것이다. 이를 해결하는 것을 &lt;strong&gt;가시성&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;volatile-변수와-가시성&quot;&gt;Volatile 변수와 가시성&lt;/h3&gt;

&lt;p&gt;Cache에서 메인 메모리로 값이 쓰는 것을 다른 책이나 문서에서는 &lt;strong&gt;flush&lt;/strong&gt;라고 표현한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;로 선언된 변수의 수정사항을 &lt;strong&gt;CPU에서 바로 메모리로 바로 flush하여 가시성을 확보한다.  하지만&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 변수는 연산의 원자성을 보장하지 않는다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 변수는 연산의 원자성은 보장하지 못하고 가시성만 보장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;atomic&quot;&gt;Atomic&lt;/h2&gt;

&lt;p&gt;이 외에도 동시성을 제어하기 위한 방법으로 &lt;strong&gt;synchronized&lt;/strong&gt; 키워드와 &lt;strong&gt;atomic&lt;/strong&gt;을 활용한 방식이 있다. Synchronized는 메소드 영역에 설정해서 메소드 자체를 임계 영역(Critical Section)으로 설정해 동시 진입을 못하게 하는 방식이다. 진입 자체를 막는 방식이기 때문에 대기 시간으로 인한 속도 이슈가 발생한다. 어떤 Thread는 Lock을 확보하느라 또 다른 Thread는 Lock을 확보하지 못해 Blocking 상태로 들어가느라 그리고 이 상태가 변경되는 동안 많은 시스템 자원이 쓰인다고 한다. (Context Switching 비용) 결국 이 문제는 성능문제로 이어진다.&lt;/p&gt;

&lt;p&gt;atomic 변수는 멀티 스레드 환경에서 원자성을 보장하기 위해 나온 개념이다. synchronized와는 다르게 blocking이 아닌 non-blocking하면서 원자성을 보장하여 동기화 문제를 해결한다. Atomic은 Compare-And-Swap(CAS) 알고리즘 방식을 사용한다. CAS는 Compare-And-Swap의 줄임말로 말 그대로 비교하고 변경하는 방식이다. 동작원리는 다음과 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;인자로 기존 값(Compared Value)과 변경할 값(Exchanged Value)을 전달한다.&lt;/li&gt;
  &lt;li&gt;기존 값(Compared Value)이 현재 메모리가 가지고 있는 값(Destination)과 같다면 변경할 값(Exchanged Value)을 반영하며 true를 반환한다.&lt;/li&gt;
  &lt;li&gt;반대로 기존 값(Compared Value)이 현재 메모리가 가지고 있는 값(Destination)과 다르다면 값을 반영하지 않고 false를 반환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;여기서 &lt;strong&gt;기존 값과 현재 메모리가 가지고 있는 값이 다른 경우라는게&lt;/strong&gt; 어떤 건지 의문이 생길 수 있다. 이 말의 의미는 스레드 A가 공유 변수에 대해 계산을 하고 메모리에 반영하기 직전에 다른 스레드 B가 공유 변수를 변경하여 메모리에 반영한 경우를 의미한다. 이때 당연히 스레드 A의 변경할 값을 메모리에 반영하면 안 된다. 따라서 false를 반환하는 경우에는 무한 루프를 구성하여 변경된 값(다른 스레드에 의해 변경된 메모리 값)을 읽고 같은 시도를 반복하거나, 다른 더 중요한 작업이 있으면 다른 작업을 해도 된다. 이 부분은 개발자가 결정한다.&lt;/p&gt;

&lt;p&gt;정리하자면 Atomic은 blocking 방식을 사용하는 synchronized에 비해 훨씬 효율적인 방법이라고 할 수 있다. 무한 루프를 돌면서 값을 반영할 수 있는지 물어보는 경우에도 스레드의 상태를 변경하는 작업이 발생하지 않으므로 성능이 더 우수하다.&lt;/p&gt;

&lt;p&gt;atomic 변수의 핵심 원리인 CAS 알고리즘은 원자성 뿐만 아니라 가시성 문제도 해결해 주는 것을 볼 수 있다. 그리고 non-blocking이 가능하므로 blocking 방식인 synchronized보다 성능 상 이점이 있다는 것도 알 수 있었다. 참고로 synchronized 키워드의 경우 synchronized 블록에 진입하기 전에 CPU 캐시 메모리와 메인 메모리 값을 동기화하여 가시성을 해결한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;https://steady-coding.tistory.com/568&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html"></summary></entry><entry><title type="html">Java8 에서 새로운 것들</title><link href="http://localhost:4000/java8-%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%83%EB%93%A4.html" rel="alternate" type="text/html" title="Java8 에서 새로운 것들" /><published>2022-08-04T00:00:00+09:00</published><updated>2022-08-04T00:00:00+09:00</updated><id>http://localhost:4000/java8-%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%83%EB%93%A4</id><content type="html" xml:base="http://localhost:4000/java8-%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%83%EB%93%A4.html">&lt;h2 id=&quot;lambda--functional-interface&quot;&gt;Lambda &amp;amp; Functional Interface&lt;/h2&gt;

&lt;h3 id=&quot;notion-lambda-참조&quot;&gt;&lt;a href=&quot;https://www.notion.so/Lambda-5690eafe0630418597eea68d43060680&quot;&gt;Notion: 🙊Lambda 참조&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;optional&quot;&gt;Optional&lt;/h2&gt;

&lt;p&gt;공식문서에서 Optional의 정의는 아래와 같이 되어있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value. null이 아닌 값을 포함하거나 포함하지 않을 수 있는 컨테이너 객체입니다. 값이 있으면 isPresent()는 true를 반환하고 get()은 값을 반환합니다.&lt;/em&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;클래스 선언부는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EMPTY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt; 클래스는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; 을 상속 받았으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 로 선언되어 있고 제네릭 클래스이다. final 로 선언되어 있다는 것은 어떤 의미일까.&lt;/p&gt;

&lt;p&gt;final 로 선언된 변수는 변경이 불가능 하지만 final 클래스라고해서 변경이 불가능 한 것은 아니다. 대신 추가적인 확장이 불가능하다. 즉, &lt;strong&gt;자식클래스를 만들 수 없다는 의미&lt;/strong&gt;다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt; 클래스는 null처리를 보다 간편하게 하기 위해서 만들어졌다. 자칫 잘못하면 NPE가 발생할 수 있는데, 이 문제를 보다 간편하고 명확하게 처리하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt;을 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;optional-생성&quot;&gt;Optional 생성&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;**값이 Null인 경우, Optional.empty()&lt;/strong&gt;**&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Optional.empty&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isPresent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;**값이 Null이 아닌 경우, Optional.of()&lt;/strong&gt;**&lt;/p&gt;

&lt;p&gt;만약 어떤 데이터가 절대 null이 아니라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional.of()&lt;/code&gt;로 생성할 수 있다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional.of()&lt;/code&gt;로 null을 저장하려고 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt;이 발생한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MyName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;**값이 Null일수도, 아닐수도 있는 경우, Optional.ofNullbale()&lt;/strong&gt;**&lt;/p&gt;

&lt;p&gt;만약 어떤 데이터가 null이 올 수도 있고 아닐 수도 있는 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional.ofNullbale&lt;/code&gt;로 생성할 수 있다. 그리고 이후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orElse&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orElseGet&lt;/code&gt; 메소드를 이용해서 &lt;strong&gt;값이 없는 경우라도 안전하게&lt;/strong&gt; 값을 가져올 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Optional의 value는 값이 있을 수도 있고 null 일 수도 있다.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;anonymous&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 값이 없다면 &quot;anonymous&quot; 를 리턴&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;optional-사용법-예시&quot;&gt;Optional 사용법 예시&lt;/h3&gt;

&lt;p&gt;예를 들어 아래와 같은 우편번호를 꺼내는 null 검사 코드가 있다고 하자. 이 코드는 null 검사 때문에 상당히 복잡하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Optional 적용 전 &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findPostCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;UserVO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userVO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userVO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPostCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;우편번호 없음&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 Optional을 사용하면 이러한 코드를 아래와 같이 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findPostCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 위의 코드를 Optional로 펼쳐놓으면 아래와 같다.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UserVO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userVO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userVO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;UserVO:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Address:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPostCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;우편번호 없음&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 그리고 위의 코드를 다음과 같이 축약해서 쓸 수 있다.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;UserVO:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Address:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPostCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;우편번호 없음&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;Optional은 null 또는 값을 감싸서 NPE(NullPointerException)로부터 부담을 줄이기 위해 등장한 Wrapper 클래스이다. Optional은 값을 Wrapping하고 다시 풀고, null 일 경우에는 대체하는 함수를 호출하는 등의 오버헤드가 있으므로 잘못 사용하면 시스템 성능이 저하된다. &lt;strong&gt;그렇기 때문에 메소드의 반환 값이 절대 null이 아니라면 Optional을 사용하지 않는 것이 좋다. 즉, Optional은 메소드의 결과가 null이 될 수 있으며, null에 의해 오류가 발생할 가능성이 매우 높을 때 반환값으로만 사용되어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;default-method&quot;&gt;Default Method&lt;/h2&gt;

&lt;p&gt;인터페이스에서 원래는 메소드 선언부만 존재해야 하지만 메소드에 default 키워드가 있으면 메소드 구현부가 포함될 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultStaticInterface&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;What is Default Method?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;since&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2022&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSince&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getEmail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;@naver.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인터페이스를 구현하는 클래스를 정의할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getEmail()&lt;/code&gt; 메소드를 구현하지 않아도 컴파일 단계에서 에러가 발생하지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultImplementChild&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultStaticInterface&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSince&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;since&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;default 키워드를 왜 사용할까. 그것은 바로 “하위호환성” 때문인데, 예를 들어 오픈소스 코드에 존재하는 인터페이스에 메소드를 추가한다고 생각해보자. 인터페이스에 메소드를 추가함으로써 해당 오픈소스 인터페이스를 사용하는 모든 사용자가 에러를 발생하고 수정을 해야되는 일이 발생할 수 있다. 이럴때 default 메소드를 사용한다면 해당 인터페이스에 메소드를 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://mangkyu.tistory.com/70&quot;&gt;참고: Tistory [Java] Optional이란?&lt;/a&gt;&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html">Lambda &amp;amp; Functional Interface</summary></entry><entry><title type="html">Generic</title><link href="http://localhost:4000/generic.html" rel="alternate" type="text/html" title="Generic" /><published>2022-08-03T00:00:00+09:00</published><updated>2022-08-03T00:00:00+09:00</updated><id>http://localhost:4000/generic</id><content type="html" xml:base="http://localhost:4000/generic.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이유-1-타입-안정성--타입-캐스팅-제거&quot;&gt;이유 1) 타입 안정성 / 타입 캐스팅 제거&lt;/h3&gt;

&lt;p&gt;아래와 같이 과일을 담는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FruitBox&lt;/code&gt;라는 클래스를 정의해보자&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fruit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;		
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bananaBox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;banana&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 타입의 오류(appleBox -&amp;gt; Banana)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사과와 바나나 객체를 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FruitBox&lt;/code&gt; 클래스에 담는다. 그러고 나서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;appleBox&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bananaBox&lt;/code&gt; 로 부터 과일을 가져오는데 여기에서 타입에 대한 문제가 발생한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;appleBox&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Banana&lt;/code&gt;를 가져오기 때문에 개발자가 의도한 바가 아니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; 타입이므로 오류도 나지 않으며 이렇기 때문에 제네릭을 사용하지 않으면 이러한 타입에 대한 오류를 컴파일 시점에 체크할 수가 없다.&lt;/p&gt;

&lt;p&gt;제네릭으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FruitBox&lt;/code&gt; 을 정의해본다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fruit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;		
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bananaBox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Banana&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;banana&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러가 발생한다.&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FruitBox&lt;/code&gt; 안에 객체 타입을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apple&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Banana&lt;/code&gt; 로 제한을 두었다. 제네릭을 적용함으로서 컴파일 시점에 타입 체크를 할 수 있다. 또한 제네릭을 통해 타입캐스팅 부분을 제거할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;이유-2-매개변수의-타입에-대한-검증&quot;&gt;이유 2) 매개변수의 타입에 대한 검증&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;./images/generic-diagram.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Vegetable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Vegetable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러, Vegetable을 Fruit에 add 할 수 없기 때문&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;제네릭-타입의-제한&quot;&gt;제네릭 타입의 제한&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;상한경계 (T extends Fruit)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;매개변수 T는 반드시 Fruit 클래스이거나 Fruit의 하위클래스여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/generic-diagram2.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하한경계 (T super Fruit)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;매개변수 T는 반드시 Fruit 클래스이거나 Fruit의 상위클래스여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/generic-diagram3.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;비한정적unbounded-와일드카드&quot;&gt;&lt;strong&gt;비한정적(Unbounded) 와일드카드&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;? 형태로 사용, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;모든 타입이 인자가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myPrintList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스가 모든 클래스의 부모클래스이기 때문에  메소드 파라메터로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 를 받아 원소를 출력할 수 있을 것으로 생각할 수 있지만 사실은 컴파일 단계에서 에러가 발생한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스가 상위 클래스인 것은 맞지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 의 하위 타입이 아니기 때문이다. 이러한 제네릭의 특성때문에 와일드카드가 필요하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myPrintList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Object:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myPrintList&lt;/code&gt; 메소드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 타입을 매개변수로 받고 있기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 타입인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strings&lt;/code&gt; 을 매개변수로 받을 수 없다. 만약에 와일드카드가 없다면 모든 타입을 대신하는 공통메소드를 작성할 수가 없다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myPrintList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 정상작동&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myPrintList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Object:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Unbounded 와일드카드를 get한 타입은 Object이다&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러. 타입이 Object 이다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Unbounded 와일드카드&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; &lt;strong&gt;에는 null만 add 할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;addDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 만약 값을 추가할 수 있다면 Integer 리스트에 double을 추가하게 됨 -&amp;gt; 오류&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;한정적bounded-와일드카드&quot;&gt;한정적(B&lt;strong&gt;ounded) 와일드카드&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;? super T 하한경계&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;비한정적 와일드카드 Unknown Type이므로 와일드카드로부터 get을 할 경우에는 최소 Object의 하위 클래스라는 점은 분명하지만 add의 파라메터로 넘겨주는 경우 해당 파라메터가 어떤 타입을 대표하는지 알수가 없다. 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 컴파일 에러&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 정상동작 - 리스트의 모든 요소가 최소 Parent 타입임을 보장한다.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;? extends Parent&amp;gt;&lt;/code&gt; 타입에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; 할때에 에러가 발생하는 이유는 extends는 상한경계이기 때문에 와일드카드에 올 수 있는 타입은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parent&lt;/code&gt;의 상속을 받는 하위클래스일 것이다. 하한경계가 없기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parent&lt;/code&gt;를 상속받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Child&lt;/code&gt; 같은 클래스에 List에 삽입될 수 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Child&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parent&lt;/code&gt;를 포함하는 부분이 아니기 때문에 타입이 맞지 않는 결과를 불러온다. 때문에 컴파일러는 에러를 나타내는 것이다. 반면에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;? super Parent&amp;gt;&lt;/code&gt; 는 타입이 최소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parent&lt;/code&gt; 임을 보장하기 때문에 add 메소드에서 에러를 발생시키지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;? extends T 상한경계&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위와 반대로 값을 꺼내오는 경우에 상한경계가 아닌 하한경계를 사용할 경우 컴파일 에러가 발생한다. 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 컴파일 에러 - Child는 Parent를 포함할 수 없다. &lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 정상동작 - 최소 Child 타입임을 보장한다.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-변수는-제네릭-타입이-될-수-없다&quot;&gt;static 변수는 제네릭 타입이 될 수 없다&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FruitBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;static 변수에 제너릭 타입은 사용할 수 없다. 왜냐하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FruitBox&lt;/code&gt; 클래스가 인스턴스가 되기 전에 static 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fruit&lt;/code&gt;은 메모리에 올라가는데 이 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fruit&lt;/code&gt;의 타입인 T가 결정되지 않기 때문에 위와 같이 사용할 수 없는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;제너릭-메소드는-static이-가능하다&quot;&gt;&lt;strong&gt;제너릭 메소드는 static이 가능하다&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;제너릭 메소드는 호출 시에 매게 타입을 지정하기 때문에 static이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raw-type&quot;&gt;Raw Type&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Raw Type&lt;/code&gt;은 타입 파라미터가 없는 제네릭 타입을 의미한다. 예를 들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 타입이다. 자바와 같은 정적 타입 언어의 강점은 프로그램을 실행하기 전에 컴파일 에러를 잡을 수 있다는 것이다. 하지만 Raw Type을 부주의하게 사용하면 런타임 에러를 일으킬 수 있다. 아래 코드는 런타임 에러를 발생시키는 예제이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// warning: unchecked call to add(E) as a member of the raw type List&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;경고가 발생하긴 하지만 컴파일이 되는 코드이다. 하지만 이 코드를 실행하면 java.lang.ClassCastException이 발생한다. 애초에 Raw Type은 자바에 제네릭이 도입되기 전(JDK 5.0 이전) 코드와 호환성을 보장하기 위한 것이다. 정적 타입 언어라는 자바의 강점을 이용하기 위해서 Raw Type을 사용하지 말아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/Vv0PGUxOzq0&quot;&gt;참고: Youtube [10분 테코톡] 🌱 시드의 제네릭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;참고: Java Docs [Raw Type]&lt;/a&gt;&lt;/p&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html"></summary></entry><entry><title type="html">Thread</title><link href="http://localhost:4000/thread.html" rel="alternate" type="text/html" title="Thread" /><published>2022-07-29T00:00:00+09:00</published><updated>2022-07-29T00:00:00+09:00</updated><id>http://localhost:4000/thread</id><content type="html" xml:base="http://localhost:4000/thread.html">&lt;p&gt;프로세스의 사전적 의미를 찾아보면 아래와 같이 정의를 내린다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램&lt;/em&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread의-의미&quot;&gt;Thread의 의미&lt;/h2&gt;

&lt;p&gt;Thread의 사전적 의미를 찾아보면 아래와 같이 정의를 내린다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;프로세스 내에서 실행되는 여러 흐름의 단위&lt;/em&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자바프로세스가 시작되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 메소드가 수행되면서 하나의 쓰레드가 시작된다&lt;/li&gt;
  &lt;li&gt;자바를 이용하여 웹을 제공할때에는 Tomcat같은 WAS를 사용하는데 이 WAS도 똑같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 메소드에서 생성한 쓰레드들이 수행되는 것&lt;/li&gt;
  &lt;li&gt;많은 쓰레드가 필요하다면 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 메소드에서 쓰레드를 생성해주면 된다&lt;/li&gt;
  &lt;li&gt;프로세스의 종료
    &lt;ul&gt;
      &lt;li&gt;싱글 쓰레드: 메인 쓰레드가 종료하면 프로세스도 종료된다&lt;/li&gt;
      &lt;li&gt;멀티 쓰레드: 실행 중인 쓰레드가 하나라도 있다면 프로세스는 종료되지 않는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread의-특징&quot;&gt;Thread의 특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 내에서 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;만 따로 할당을 받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heap&lt;/code&gt; 영역을 공유한다.&lt;/li&gt;
  &lt;li&gt;공유하는 메모리로 인해 독립적인 프로세스와는 다르게 쓰레드간 데이터를 주고 받는게 간단해지고 시스템 자원 소모가 줄어들게 된다.&lt;/li&gt;
  &lt;li&gt;공유하는 메모리로 인해 Context Switching에 대한 오버헤드가 줄어든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread를-생성하는-방법&quot;&gt;Thread를 생성하는 방법&lt;/h2&gt;

&lt;p&gt;쓰레드를 생성하는 방법은 크게 두 가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt; 클래스를 사용하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 인터페이스를 이용하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 인터페이스와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt; 클래스는 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang&lt;/code&gt; 패키지에 있다. 따라서 이 인터페이스나 클래스를 사용할 때는 별도로 import할 필요가 없다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 인터페이스에 선언되어 있는 메소드는 단지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run()&lt;/code&gt; 하나이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run()&lt;/code&gt; 메소드는 쓰레드를 통해 작업하고 싶은 내용이 들어가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runnable 구현 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunnableSample&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 쓰레드가 실행할 코드&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Thead 상속 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSample&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 쓰레드가 실행할 코드&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Thead와 Runnable 실행방법의 차이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;두개의 예제 모두 간단하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run()&lt;/code&gt; 메소드를 정의하였고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RunnableSample&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadSample&lt;/code&gt; 클래스 모두 쓰레드로 실행할 수 있다는 공통점이 있다. 하지만 이 두개의 클래스를 실행하는 방식은 다르다. 아래 예제는 쓰레드를 수행하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RunTreads&lt;/code&gt;라는 클래스이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunThreads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;RunThreads&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;runBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Runnable 인터페이스를 구현한 쓰레드 시작&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;RunnableSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunnableSample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Thread 클래스를 상속받은 쓰레드 시작&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;ThreadSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Runnable을 구현한 부분을 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new Thread(runnable).start();&lt;/code&gt; 라고 나와있는거 처럼 쓰레드로 바로 시작할 수는 없다. 따라서 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해주어야만 한다. 쓰레드를 시작하는 메소드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start()&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thread 클래스와 Runnable 인터페이스, 언제 쓸까&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인터페이스와 클래스 각 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start()&lt;/code&gt; 메소드를 호출하게 되면서 쓰레드가 시작된다. 쓰레드가 다른 클래스를 확장할 필요가 있을때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 인터페이스르 구현하면 되며 그렇지 않은 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt;클래스를 사용하는 것이 편하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;thread를-실행할-때-start와-run의-차이&quot;&gt;&lt;strong&gt;Thread를 실행할 때 start()와 run()의 차이&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;run()을 호출하는 것은 생성된 스레드 객체를 실행하는 것이 아니라, 단순히 스레드 클래스 내부의 run 메서드를 실행시키는 것이다.&lt;/p&gt;

&lt;p&gt;즉, main 함수의 스레드를 그대로 사용해서 run 메서드를 실행하기 때문에 &lt;strong&gt;새로운 스레드가 생기지 않고 병렬처리를 할 수 없다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;반면에 start()는 새로운 스레드를 실행하는데 필요한 호출 스택(call stack)을 생성한 다음에 run을 호출해서, 생성된 호출 스택에 run()이 첫 번째로 저장되게 한다.&lt;/p&gt;

&lt;p&gt;좀 더 쉽게 말하면, start()를 호출하면 스레드를 새롭게 생성해서 해당 스레드를 runnable 한 상태로 만든 후 run() 메서드를 실행하게 된다. 따라서 &lt;strong&gt;start()를 호출해야만 멀티스레드로 병렬 처리가 가능해진다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread-예제&quot;&gt;Thread 예제&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Thread를 상속받은 ModifyAmountThread 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModifyAmountThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt;  &lt;span class=&quot;nc&quot;&gt;CommonCalculate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFlag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ModifyAmountThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CommonCalculate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFlag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addFlag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addFlag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addFlag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;minus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;연산을 정의해놓은 CommonCalculate 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonCalculate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CommonCalculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 방법 1. synchronized 동기화 - 메소드 전체&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;minus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;cm&quot;&gt;/*
		
		방법.2 synchronized 블록을 통해 동기화 처리 할 부분을 지정.
		
		private Object lock = new Object();

		...
		public void plus(int value) {
        synchronized (lock) {
            amount+=value;
        }
    }
    public void minus(int value) {
        synchronized (lock) {
            amount-=value;
        }
    }

		*/&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Thread 생성 및 실행 클래스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunSync&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;RunSync&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runSync&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunSync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;runSync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;runCommonCalculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runCommonCalculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CommonCalculate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonCalculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

				&lt;span class=&quot;c1&quot;&gt;// 쓰레드1, 쓰레드2 생성 동일한 calc 객체를 사용한다.&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ModifyAmountThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModifyAmountThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ModifyAmountThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModifyAmountThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;c1&quot;&gt;// thread1, thread2가 종료될때까지 메인쓰레드를 대기시킨다.&lt;/span&gt;
						&lt;span class=&quot;c1&quot;&gt;// join을 통해 쓰레드가 수행하는 연산에 대한 결과를 볼 수 있다.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Final Value is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데몬쓰레드&quot;&gt;데몬쓰레드&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주 쓰레드의 백그라운드에서 작업을 돕는 보조적인 역할을 수행하는 쓰레드.&lt;/li&gt;
  &lt;li&gt;주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료된다.&lt;/li&gt;
  &lt;li&gt;JVM은 데몬쓰레드의 종료를 기다리지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runDaemonThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;ThreadSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDaemon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 데몬쓰레드&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스레드를-많이-띄어야-하는-상황-io가-걸릴때마다&quot;&gt;&lt;strong&gt;스레드를 많이 띄어야 하는 상황 (I/O가 걸릴때마다)&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;대기 시간 즉 cpu가 i/o처리 시 block 걸리는 시간이 길 때 (ex, 대용량 파일 I/O 발생, 긴 네트워크 지연 발생)에는 스레드 개수를 늘려서 대기시간(block io 시간)을 줄여야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동시성과-병렬성&quot;&gt;동시성과 병렬성&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;동시성&lt;/th&gt;
      &lt;th&gt;병렬성&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;동시에 실행되는 것 같이 보이는 것&lt;/td&gt;
      &lt;td&gt;실제로 동시에 여러 작업이 처리되는 것&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;싱글 코어에서 멀티 쓰레드(Multi thread)를 동작 시키는 방식&lt;/td&gt;
      &lt;td&gt;멀티 코어에서 멀티 쓰레드(Multi thread)를 동작시키는 방식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;한번에 많은 것을 처리&lt;/td&gt;
      &lt;td&gt;한번에 많은 일을 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;논리적인 개념&lt;/td&gt;
      &lt;td&gt;물리적인 개념&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html">프로세스의 사전적 의미를 찾아보면 아래와 같이 정의를 내린다.</summary></entry><entry><title type="html">Collection Framework</title><link href="http://localhost:4000/collection-framework.html" rel="alternate" type="text/html" title="Collection Framework" /><published>2022-07-22T00:00:00+09:00</published><updated>2022-07-22T00:00:00+09:00</updated><id>http://localhost:4000/collection-framework</id><content type="html" xml:base="http://localhost:4000/collection-framework.html">&lt;p&gt;&lt;img src=&quot;./images/collection-diagram.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h3&gt;

&lt;p&gt;ArrayList의 상속관계는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Object&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AbstractCollection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AbstractList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;javaj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt; 정의된 부분을 보면 다음과 같이 되어있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cloneable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://techblog.woowahan.com/2550/&quot;&gt;참고: 우아한형제들 기술블로그 자바 직렬화, 그것이 알고싶다&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;: 생성한 객체를 JSON로 저장하여 API로 데이터를 전달할 수 있음을 지정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;: Object 클래스의 clone 메소드로 객체의 복제가 가능함을 명시&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RandomAccess&lt;/code&gt;: 목록형 데이터에 액세스할 때 우수한 성능을 제공하도록 동작을 변경할 수 있도록 하는 것&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;: 목록형 데이터를 처리하는것과 관련된 메소드 지정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단반향 포인터 구조로 데이터 순차적 접근에 강점을 가진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;배열을 기반으로 데이터를 저장한다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 삽입, 삭제가 느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 검색이 빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Thread Safe 하지 않음&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ArrayList는 List 컬렉션 인터페이스를 구현한 클래스이다. List 컬렉션처럼 인덱스로 객체를 관리한다.일반 배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서 동일하지만, 크기를 동적으로 늘릴 수 있다는 점에서 차이점이 있다. 배열은 처음 생성할 때 고정 크기를 지정하며, 사용 중에 크기를 변경할 수 없다. 만약 크기를 늘려야 한다면 새로 배열을 선언해야 한다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vector&quot;&gt;Vector&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ArrayList의 구형버전이며, 모든 메소드가 동기화 되어있음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;잘 쓰이진 않음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Thread Safe&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vector는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector 객체를 생성하기 위해서는 저장할 타입을 지정해야 한다. ArrayList와 차이점으로는 Vector 클래스는 동기화된(synchronized) 메서드로 구성되어 있다. 그렇기 때문에 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 즉, 스레드에 안전하다(Thread Safe)라고 말합니다. 다만 동기화되어 있기 때문에 ArrayList 보다는 객체를 추가, 삭제하는 과정은 느릴수 밖에 없다. 안전성을 추구하는데 있어서 속도를 포기한 트레이드 오프(trade off)이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractSequentialList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Deque&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cloneable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Serializable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;양방향 포인터 구조로 데이터 삽입, 삭제가 빠르다. (ArrayList과 다른 점)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ArrayList보다 검색이 느리다&lt;/li&gt;
  &lt;li&gt;LinkedList는 List도되고 Queue의 기능을 모두 구현하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LinkedList는 List 구현 클래스이다. 내부 구조는 ArrayList와 다르다 .ArrayList에는 내부 배열에 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다. 그렇기 때문에LinkedList에서 특정 인덱스의 객체를 제거하게 되면, 제거되는 인덱스의 앞 뒤 링크만 변경되고 나머지 링크는 변경되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;set&quot;&gt;Set&lt;/h2&gt;

&lt;p&gt;Set은 순서에 상관없이 어떤 데이터가 존재하는지 확인하기 위한 용도로 많이 사용된다. 다시 말해서 중복되는 것을 방지하고, 원하는 값이 포함되어 있는지를 확인하는 것이 주 용도다. 예를 들어 어떤 서버에 1분간 요청한 로그가 있다. 이 서버에 붙어서 &lt;strong&gt;요청한 IP를 기준으로 사용자의 수가 얼마나 되는지 확인한다고 가정&lt;/strong&gt;해보자. 1분간 동일한 서버에 요청하는 중복 사용자 수는 매우 많다. 만약에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 로 확인하려고 한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indexOf()&lt;/code&gt; 로 해당 사용자가 요청한 내역이 있는지 먼저 확인 후 없으면 add 메소드로 추가하는 방식으로 해야될 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt; 을 사용하게 되면 이런 반복적인 작업을 피하고 데이터를 그냥 추가해주는 것만으로 원하는 작업의 구현이 가능하다. 어떤 값이 존재하는지 없는지 여부만 중요할 때 Set을 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashset&quot;&gt;HashSet&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;HashSet의 상속관계&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Object&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AbstractCollection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AbstractSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;javaj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정렬없이 순서가 전혀 필요없는 데이터를 해시 테이블에 저장한다. Set 중에 가장 성능이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;treeset&quot;&gt;TreeSet&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;저장된 데이터의 값이 따라 정렬&lt;/strong&gt;되는 셋이다. red-black이라는 트리 타입으로 값이 저장되며 HashSet보다는 성능이 느리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;map&quot;&gt;Map&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;모든 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;가 존재한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;는 해당 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt;에서 고유해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt; 는 중복되어도 괜찮다.&lt;/li&gt;
  &lt;li&gt;데이터간의 순서는 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashmap-과-hashtable의-비교&quot;&gt;HashMap 과 Hashtable의 비교&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/wjdrbs96/Today-I-Learn/blob/master/Java/Collection/Map/Java&quot;&gt;참고: github Java HashMap은 어떻게 동작하는가?&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java에 Collection이라는 인터페이스가 추가된 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JDK 1.2&lt;/code&gt;, HashMap과 TreeMap도 이때 추가되었다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JDK 1.0&lt;/code&gt; 버전부터 있었던 클래스이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;은 &lt;strong&gt;Thread-safe&lt;/strong&gt;하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;은 &lt;strong&gt;Thread-unsafe&lt;/strong&gt; 라는 특징을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;은 key에 &lt;strong&gt;null을 허용하지 않지만&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;은 &lt;strong&gt;key에 null을 허용&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;은 보조해시를 사용하기 때문에 보조 해시함수를 사용하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;에 비하여 해시충돌(hash collision)이 덜 발생할 수 있어 상대적으로 성능상 이점이 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hashtable의 구현부&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Hashtable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cloneable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HashMap의 구현부&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cloneable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hashmap&quot;&gt;HashMap&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;의 key는 기본 자료형과 참조형 모두 될 수 있다. 그래서 보통 int, String 같은 걸 쓰기도 하는데, 개발자가 직접 클래스를 만들어 그 클래스를 key로 사용한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt; 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equals()&lt;/code&gt; 를 잘 구현해놓아야 한다.&lt;/li&gt;
  &lt;li&gt;정렬된 key목록의 Map을 원한다면  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 을 활용하자.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sun Hong Lee</name></author><category term="2022" /><summary type="html"></summary></entry></feed>